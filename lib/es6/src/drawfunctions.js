// Generated by BUCKLESCRIPT VERSION 1.6.1, PLEASE EDIT WITH CARE
'use strict';

import * as Font         from "./font";
import * as Curry        from "bs-platform/lib/es6/curry";
import * as Utils        from "./utils";
import * as Matrix       from "./matrix";
import * as WGLWebgl     from "reasongl-web/lib/es6/src/wGLWebgl";
import * as Glhelpers    from "./glhelpers";
import * as Pervasives   from "bs-platform/lib/es6/pervasives";
import * as RGLConstants from "reasongl-interface/lib/es6/src/rGLConstants";

function width(env) {
  return env[/* size */18][/* width */1];
}

function height(env) {
  return env[/* size */18][/* height */0];
}

function mouse(env) {
  return env[/* mouse */12][/* pos */0];
}

function pmouse(env) {
  return env[/* mouse */12][/* prevPos */1];
}

function mousePressed(env) {
  return env[/* mouse */12][/* pressed */2];
}

function keyCode(env) {
  return env[/* keyboard */11][/* keyCode */0];
}

function translate(dx, dy, env) {
  return Matrix.matmatmul(env[/* matrix */16], Matrix.createTranslation(dx, dy));
}

function rotate(theta, env) {
  return Matrix.matmatmul(env[/* matrix */16], Matrix.createRotation(theta));
}

function fill(c, env) {
  var init = env[/* style */13];
  env[/* style */13] = /* record */[
    /* strokeColor */init[/* strokeColor */0],
    /* strokeWeight */init[/* strokeWeight */1],
    /* fillColor : Some */[c]
  ];
  return /* () */0;
}

function noFill(env) {
  var init = env[/* style */13];
  env[/* style */13] = /* record */[
    /* strokeColor */init[/* strokeColor */0],
    /* strokeWeight */init[/* strokeWeight */1],
    /* fillColor : None */0
  ];
  return /* () */0;
}

function stroke(color, env) {
  var init = env[/* style */13];
  env[/* style */13] = /* record */[
    /* strokeColor : Some */[color],
    /* strokeWeight */init[/* strokeWeight */1],
    /* fillColor */init[/* fillColor */2]
  ];
  return /* () */0;
}

function noStroke(env) {
  var init = env[/* style */13];
  env[/* style */13] = /* record */[
    /* strokeColor : None */0,
    /* strokeWeight */init[/* strokeWeight */1],
    /* fillColor */init[/* fillColor */2]
  ];
  return /* () */0;
}

function strokeWeight(weight, env) {
  var init = env[/* style */13];
  env[/* style */13] = /* record */[
    /* strokeColor */init[/* strokeColor */0],
    /* strokeWeight */weight,
    /* fillColor */init[/* fillColor */2]
  ];
  return /* () */0;
}

function pushStyle(env) {
  env[/* styleStack */14] = /* :: */[
    env[/* style */13],
    env[/* styleStack */14]
  ];
  return /* () */0;
}

function popStyle(env) {
  var match = env[/* styleStack */14];
  if (match) {
    env[/* style */13] = match[0];
    env[/* styleStack */14] = match[1];
    return /* () */0;
  } else {
    return Pervasives.failwith("Too many `popStyle` without enough `pushStyle`.");
  }
}

function frameRate(env) {
  return env[/* frame */15][/* rate */1];
}

function frameCount(env) {
  return env[/* frame */15][/* count */0];
}

function size(width, height, env) {
  Curry._3(WGLWebgl.Gl[/* Window */2][/* setWindowSize */3], env[/* window */1], width, height);
  return Glhelpers.resetSize(env, width, height);
}

function resizeable(resizeable$1, env) {
  env[/* size */18][/* resizeable */2] = resizeable$1;
  return /* () */0;
}

function image(img, x, y, env) {
  var match = img[0];
  if (match) {
    var i = match[0];
    return Glhelpers.drawImageInternal(i, x, y, 0, 0, i[/* width */3], i[/* height */2], env);
  } else {
    console.log("image not ready yet, just doing nothing :D");
    return /* () */0;
  }
}

function clear(env) {
  return Curry._2(WGLWebgl.Gl[/* clear */39], env[/* gl */2], RGLConstants.color_buffer_bit | RGLConstants.depth_buffer_bit);
}

function linef(p1, p2, env) {
  var match = env[/* style */13][/* strokeColor */0];
  if (match) {
    var partial_arg = env[/* matrix */16];
    var transform = function (param) {
      return Matrix.matptmul(partial_arg, param);
    };
    var match_000 = Curry._1(transform, p1);
    var match_001 = Curry._1(transform, p2);
    var match$1 = match_001;
    var yy2 = match$1[1];
    var xx2 = match$1[0];
    var match$2 = match_000;
    var yy1 = match$2[1];
    var xx1 = match$2[0];
    var dx = xx2 - xx1;
    var dy = yy2 - yy1;
    var mag = Curry._2(Utils.PUtils[/* distf */22], /* tuple */[
          xx1,
          yy1
        ], /* tuple */[
          xx2,
          yy2
        ]);
    var radius = env[/* style */13][/* strokeWeight */1] / 2;
    var xthing = dy / mag * radius;
    var ything = -dx / mag * radius;
    var x1 = xx2 + xthing;
    var y1 = yy2 + ything;
    var x2 = xx1 + xthing;
    var y2 = yy1 + ything;
    var x3 = xx2 - xthing;
    var y3 = yy2 - ything;
    var x4 = xx1 - xthing;
    var y4 = yy1 - ything;
    return Glhelpers.addRectToGlobalBatch(env, /* tuple */[
                x1,
                y1
              ], /* tuple */[
                x2,
                y2
              ], /* tuple */[
                x3,
                y3
              ], /* tuple */[
                x4,
                y4
              ], match[0]);
  } else {
    return /* () */0;
  }
}

function line(param, param$1, env) {
  return linef(/* tuple */[
              param[0],
              param[1]
            ], /* tuple */[
              param$1[0],
              param$1[1]
            ], env);
}

function ellipsef(center, rx, ry, env) {
  var match = env[/* style */13][/* fillColor */2];
  if (match) {
    Glhelpers.drawEllipseInternal(env, center, rx, ry, env[/* matrix */16], match[0]);
  }
  var match$1 = env[/* style */13][/* strokeColor */0];
  if (match$1) {
    return Glhelpers.drawArcStroke(env, center, rx, ry, 0, Utils.PConstants[/* tau */6], /* false */0, /* false */0, env[/* matrix */16], match$1[0], env[/* style */13][/* strokeWeight */1]);
  } else {
    return /* () */0;
  }
}

function ellipse(param, rx, ry, env) {
  return ellipsef(/* tuple */[
              param[0],
              param[1]
            ], rx, ry, env);
}

function quadf(p1, p2, p3, p4, env) {
  var partial_arg = env[/* matrix */16];
  var transform = function (param) {
    return Matrix.matptmul(partial_arg, param);
  };
  var match_000 = Curry._1(transform, p1);
  var match_001 = Curry._1(transform, p2);
  var match_002 = Curry._1(transform, p3);
  var match_003 = Curry._1(transform, p4);
  var p4$1 = match_003;
  var p3$1 = match_002;
  var p2$1 = match_001;
  var p1$1 = match_000;
  var match = env[/* style */13][/* fillColor */2];
  if (match) {
    Glhelpers.addRectToGlobalBatch(env, p3$1, p4$1, p2$1, p1$1, match[0]);
  }
  var match$1 = env[/* style */13][/* strokeColor */0];
  if (match$1) {
    var color = match$1[0];
    linef(p1$1, p2$1, env);
    linef(p2$1, p3$1, env);
    linef(p3$1, p4$1, env);
    linef(p4$1, p1$1, env);
    var r = env[/* style */13][/* strokeWeight */1] / 2;
    Glhelpers.drawEllipseInternal(env, p1$1, r, r, Matrix.identity, color);
    Glhelpers.drawEllipseInternal(env, p2$1, r, r, Matrix.identity, color);
    Glhelpers.drawEllipseInternal(env, p3$1, r, r, Matrix.identity, color);
    return Glhelpers.drawEllipseInternal(env, p4$1, r, r, Matrix.identity, color);
  } else {
    return /* () */0;
  }
}

function quad(param, param$1, param$2, param$3, env) {
  return quadf(/* tuple */[
              param[0],
              param[1]
            ], /* tuple */[
              param$1[0],
              param$1[1]
            ], /* tuple */[
              param$2[0],
              param$2[1]
            ], /* tuple */[
              param$3[0],
              param$3[1]
            ], env);
}

function rectf(x, y, width, height, env) {
  return quadf(/* tuple */[
              x,
              y
            ], /* tuple */[
              x + width,
              y
            ], /* tuple */[
              x + width,
              y + height
            ], /* tuple */[
              x,
              y + height
            ], env);
}

var rect = rectf;

function bezier(param, param$1, param$2, param$3, env) {
  var yy4 = param$3[1];
  var xx4 = param$3[0];
  var yy3 = param$2[1];
  var xx3 = param$2[0];
  var yy2 = param$1[1];
  var xx2 = param$1[0];
  var yy1 = param[1];
  var xx1 = param[0];
  var bezier_point = function (t) {
    return /* tuple */[
            Math.pow(1 - t, 3) * xx1 + 3 * Math.pow(1 - t, 2) * t * xx2 + 3 * (1 - t) * Math.pow(t, 2) * xx3 + Math.pow(t, 3) * xx4,
            Math.pow(1 - t, 3) * yy1 + 3 * Math.pow(1 - t, 2) * t * yy2 + 3 * (1 - t) * Math.pow(t, 2) * yy3 + Math.pow(t, 3) * yy4
          ];
  };
  for(var i = 0; i <= 99; ++i){
    linef(bezier_point(i / 100.0), bezier_point((i + 1 | 0) / 100.0), env);
  }
  return /* () */0;
}

function pixelf(x, y, color, env) {
  var w = env[/* style */13][/* strokeWeight */1];
  return Glhelpers.addRectToGlobalBatch(env, /* tuple */[
              x + w,
              y + w
            ], /* tuple */[
              x,
              y + w
            ], /* tuple */[
              x + w,
              y
            ], /* tuple */[
              x,
              y
            ], color);
}

var pixel = pixelf;

function trianglef(p1, p2, p3, env) {
  var partial_arg = env[/* matrix */16];
  var transform = function (param) {
    return Matrix.matptmul(partial_arg, param);
  };
  var match_000 = Curry._1(transform, p1);
  var match_001 = Curry._1(transform, p2);
  var match_002 = Curry._1(transform, p3);
  var p3$1 = match_002;
  var p2$1 = match_001;
  var p1$1 = match_000;
  var match = env[/* style */13][/* fillColor */2];
  if (match) {
    Glhelpers.drawTriangleInternal(env, p1$1, p2$1, p3$1, match[0]);
  }
  var match$1 = env[/* style */13][/* strokeColor */0];
  if (match$1) {
    var color = match$1[0];
    linef(p1$1, p2$1, env);
    linef(p2$1, p3$1, env);
    linef(p3$1, p1$1, env);
    var r = env[/* style */13][/* strokeWeight */1] / 2;
    Glhelpers.drawEllipseInternal(env, p1$1, r, r, Matrix.identity, color);
    Glhelpers.drawEllipseInternal(env, p2$1, r, r, Matrix.identity, color);
    return Glhelpers.drawEllipseInternal(env, p3$1, r, r, Matrix.identity, color);
  } else {
    return /* () */0;
  }
}

function triangle(param, param$1, param$2, env) {
  return trianglef(/* tuple */[
              param[0],
              param[1]
            ], /* tuple */[
              param$1[0],
              param$1[1]
            ], /* tuple */[
              param$2[0],
              param$2[1]
            ], env);
}

function arcf(centerPt, rx, ry, start, stop, isOpen, isPie, env) {
  var match = env[/* style */13][/* fillColor */2];
  if (match) {
    Glhelpers.drawArcInternal(env, centerPt, rx, ry, start, stop, isPie, env[/* matrix */16], match[0]);
  }
  var match$1 = env[/* style */13][/* strokeColor */0];
  if (match$1) {
    return Glhelpers.drawArcStroke(env, centerPt, rx, ry, start, stop, isOpen, isPie, env[/* matrix */16], match$1[0], env[/* style */13][/* strokeWeight */1]);
  } else {
    return /* () */0;
  }
}

function arc(param, rx, ry, start, stop, isOpen, isPie, env) {
  return arcf(/* tuple */[
              param[0],
              param[1]
            ], rx, ry, start, stop, isOpen, isPie, env);
}

function loadFont(filename, env) {
  return Curry._2(Font.Font[/* parseFontFormat */8], env, filename);
}

function text(fnt, str, x, y, env) {
  return Curry._5(Font.Font[/* drawString */11], env, fnt, str, x, y);
}

function background(color, env) {
  var w = env[/* size */18][/* width */1];
  var h = env[/* size */18][/* height */0];
  return Glhelpers.addRectToGlobalBatch(env, /* tuple */[
              w,
              h
            ], /* tuple */[
              0,
              h
            ], /* tuple */[
              w,
              0
            ], /* tuple */[
              0,
              0
            ], color);
}

var P = /* module */[
  /* width */width,
  /* height */height,
  /* mouse */mouse,
  /* pmouse */pmouse,
  /* mousePressed */mousePressed,
  /* keyCode */keyCode,
  /* translate */translate,
  /* rotate */rotate,
  /* fill */fill,
  /* noFill */noFill,
  /* stroke */stroke,
  /* noStroke */noStroke,
  /* strokeWeight */strokeWeight,
  /* pushStyle */pushStyle,
  /* popStyle */popStyle,
  /* frameRate */frameRate,
  /* frameCount */frameCount,
  /* size */size,
  /* resizeable */resizeable,
  /* loadImage */Glhelpers.loadImage,
  /* image */image,
  /* clear */clear,
  /* linef */linef,
  /* line */line,
  /* ellipsef */ellipsef,
  /* ellipse */ellipse,
  /* quadf */quadf,
  /* quad */quad,
  /* rectf */rectf,
  /* rect */rect,
  /* bezier */bezier,
  /* pixelf */pixelf,
  /* pixel */pixel,
  /* trianglef */trianglef,
  /* triangle */triangle,
  /* arcf */arcf,
  /* arc */arc,
  /* loadFont */loadFont,
  /* text */text,
  /* background */background
];

export {
  P ,
  
}
/* Font Not a pure module */
