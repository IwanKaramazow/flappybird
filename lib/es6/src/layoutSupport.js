// Generated by BUCKLESCRIPT VERSION 1.6.1, PLEASE EDIT WITH CARE
'use strict';

import * as Caml_obj                from "bs-platform/lib/es6/caml_obj";
import * as LayoutValue             from "./layoutValue";
import * as Caml_builtin_exceptions from "bs-platform/lib/es6/caml_builtin_exceptions";

function dummyMeasure(_, _$1, _$2, _$3, _$4) {
  throw [
        Caml_builtin_exceptions.invalid_argument,
        "A node does not have its measure function  implemented, yet requires measurement"
      ];
}

function dummyIsDirty() {
  return /* false */0;
}

var dummyCachedMeasurement = /* record */[
  /* availableWidth */LayoutValue.zero,
  /* availableHeight */LayoutValue.zero,
  /* widthMeasureMode : CSS_MEASURE_MODE_NEGATIVE_ONE_WHATEVER_THAT_MEANS */0,
  /* heightMeasureMode : CSS_MEASURE_MODE_NEGATIVE_ONE_WHATEVER_THAT_MEANS */0,
  /* computedWidth */LayoutValue.zero,
  /* computedHeight */LayoutValue.zero
];

var defaultStyle = /* record */[
  /* direction : CssDirectionInherit */1,
  /* flexDirection : CssFlexDirectionColumn */2,
  /* justifyContent : CssJustifyFlexStart */0,
  /* alignContent : CssAlignFlexStart */1,
  /* alignItems : CssAlignStretch */4,
  /* alignSelf : CssAlignAuto */0,
  /* positionType : CssPositionRelative */0,
  /* flexWrap : CssNoWrap */0,
  /* overflow : Visible */0,
  /* flexGrow */LayoutValue.zero,
  /* flexShrink */LayoutValue.zero,
  /* flexBasis */LayoutValue.cssUndefined,
  /* marginLeft */LayoutValue.zero,
  /* marginTop */LayoutValue.zero,
  /* marginRight */LayoutValue.zero,
  /* marginBottom */LayoutValue.zero,
  /* marginStart */LayoutValue.cssUndefined,
  /* marginEnd */LayoutValue.cssUndefined,
  /* width */LayoutValue.cssUndefined,
  /* height */LayoutValue.cssUndefined,
  /* minWidth */LayoutValue.cssUndefined,
  /* minHeight */LayoutValue.cssUndefined,
  /* maxWidth */LayoutValue.cssUndefined,
  /* maxHeight */LayoutValue.cssUndefined,
  /* left */LayoutValue.cssUndefined,
  /* top */LayoutValue.cssUndefined,
  /* right */LayoutValue.cssUndefined,
  /* bottom */LayoutValue.cssUndefined,
  /* start */LayoutValue.cssUndefined,
  /* endd */LayoutValue.cssUndefined,
  /* paddingLeft */LayoutValue.zero,
  /* paddingTop */LayoutValue.zero,
  /* paddingRight */LayoutValue.zero,
  /* paddingBottom */LayoutValue.zero,
  /* paddingStart */LayoutValue.cssUndefined,
  /* paddingEnd */LayoutValue.cssUndefined,
  /* borderLeft */LayoutValue.zero,
  /* borderTop */LayoutValue.zero,
  /* borderRight */LayoutValue.zero,
  /* borderBottom */LayoutValue.zero,
  /* borderStart */LayoutValue.cssUndefined,
  /* borderEnd */LayoutValue.cssUndefined
];

var theNullNode = [];

Caml_obj.caml_update_dummy(theNullNode, /* record */[
      /* style */defaultStyle,
      /* layout : record */[
        /* left */LayoutValue.zero,
        /* top */LayoutValue.zero,
        /* right */LayoutValue.zero,
        /* bottom */LayoutValue.zero,
        /* width */LayoutValue.cssUndefined,
        /* height */LayoutValue.cssUndefined,
        /* direction : CssDirectionInherit */1,
        /* hasNewLayout : true */1,
        /* generationCount */0,
        /* lastParentDirection : CSS_DIRECTION_NEGATIVE_ONE_WHATEVER_THAT_MEANS */0,
        /* computedFlexBasis */LayoutValue.cssUndefined,
        /* nextCachedMeasurementsIndex */0,
        /* cachedMeasurement1 */dummyCachedMeasurement,
        /* cachedMeasurement2 */dummyCachedMeasurement,
        /* cachedMeasurement3 */dummyCachedMeasurement,
        /* cachedMeasurement4 */dummyCachedMeasurement,
        /* cachedMeasurement5 */dummyCachedMeasurement,
        /* cachedMeasurement6 */dummyCachedMeasurement,
        /* measuredWidth */LayoutValue.cssUndefined,
        /* measuredHeight */LayoutValue.cssUndefined,
        /* cachedLayout */dummyCachedMeasurement
      ],
      /* lineIndex */0,
      /* nextChild */theNullNode,
      /* measure */dummyMeasure,
      /* print : None */0,
      /* children : array */[],
      /* isDirty */dummyIsDirty,
      /* context : () */0
    ]);

function createNode(children, $staropt$star, context) {
  var style = $staropt$star ? $staropt$star[0] : defaultStyle;
  var newrecord = theNullNode[/* layout */1].slice();
  return /* record */[
          /* style */style,
          /* layout */(newrecord[/* direction */6] = /* CssDirectionInherit */1, newrecord),
          /* lineIndex */theNullNode[/* lineIndex */2],
          /* nextChild */theNullNode[/* nextChild */3],
          /* measure */theNullNode[/* measure */4],
          /* print */theNullNode[/* print */5],
          /* children */children,
          /* isDirty */theNullNode[/* isDirty */7],
          /* context */context
        ];
}

function layoutMeasuredDimensionForAxis(node, axis) {
  if (axis >= 2) {
    return node[/* layout */1][/* measuredHeight */19];
  } else {
    return node[/* layout */1][/* measuredWidth */18];
  }
}

function layoutPosPositionForAxis(node, axis) {
  switch (axis) {
    case 0 : 
        return node[/* layout */1][/* left */0];
    case 1 : 
        return node[/* layout */1][/* right */2];
    case 2 : 
        return node[/* layout */1][/* top */1];
    case 3 : 
        return node[/* layout */1][/* bottom */3];
    
  }
}

function layoutTrailingPositionForAxis(node, axis) {
  switch (axis) {
    case 0 : 
        return node[/* layout */1][/* right */2];
    case 1 : 
        return node[/* layout */1][/* left */0];
    case 2 : 
        return node[/* layout */1][/* bottom */3];
    case 3 : 
        return node[/* layout */1][/* top */1];
    
  }
}

function styleDimensionForAxis(node, axis) {
  if (axis >= 2) {
    return node[/* style */0][/* height */19];
  } else {
    return node[/* style */0][/* width */18];
  }
}

function styleLeadingPositionForAxis(node, axis) {
  switch (axis) {
    case 0 : 
        return node[/* style */0][/* left */24];
    case 1 : 
        return node[/* style */0][/* right */26];
    case 2 : 
        return node[/* style */0][/* top */25];
    case 3 : 
        return node[/* style */0][/* bottom */27];
    
  }
}

function styleLeadingPositionForAxisOrZero(node, axis) {
  var leadingPos = styleLeadingPositionForAxis(node, axis);
  var match = 1 - LayoutValue.isUndefined(leadingPos);
  if (match !== 0) {
    return leadingPos;
  } else {
    return LayoutValue.zero;
  }
}

function styleLeadingPaddingForAxis(node, axis) {
  switch (axis) {
    case 0 : 
        return node[/* style */0][/* paddingLeft */30];
    case 1 : 
        return node[/* style */0][/* paddingRight */32];
    case 2 : 
        return node[/* style */0][/* paddingTop */31];
    case 3 : 
        return node[/* style */0][/* paddingBottom */33];
    
  }
}

function styleLeadingMarginForAxis(node, leadingAxis) {
  switch (leadingAxis) {
    case 0 : 
        return node[/* style */0][/* marginLeft */12];
    case 1 : 
        return node[/* style */0][/* marginRight */14];
    case 2 : 
        return node[/* style */0][/* marginTop */13];
    case 3 : 
        return node[/* style */0][/* marginBottom */15];
    
  }
}

function styleLeadingBorderForAxis(node, leadingAxis) {
  switch (leadingAxis) {
    case 0 : 
        return node[/* style */0][/* borderLeft */36];
    case 1 : 
        return node[/* style */0][/* borderRight */38];
    case 2 : 
        return node[/* style */0][/* borderTop */37];
    case 3 : 
        return node[/* style */0][/* borderBottom */39];
    
  }
}

function styleTrailingPositionForAxis(node, axis) {
  switch (axis) {
    case 0 : 
        return node[/* style */0][/* right */26];
    case 1 : 
        return node[/* style */0][/* left */24];
    case 2 : 
        return node[/* style */0][/* bottom */27];
    case 3 : 
        return node[/* style */0][/* top */25];
    
  }
}

function styleTrailingPositionForAxisOrZero(node, axis) {
  var leadingPos = styleTrailingPositionForAxis(node, axis);
  var match = 1 - LayoutValue.isUndefined(leadingPos);
  if (match !== 0) {
    return leadingPos;
  } else {
    return LayoutValue.zero;
  }
}

function styleTrailingPaddingForAxis(node, axis) {
  switch (axis) {
    case 0 : 
        return node[/* style */0][/* paddingRight */32];
    case 1 : 
        return node[/* style */0][/* paddingLeft */30];
    case 2 : 
        return node[/* style */0][/* paddingBottom */33];
    case 3 : 
        return node[/* style */0][/* paddingTop */31];
    
  }
}

function styleTrailingMarginForAxis(node, trailingAxis) {
  switch (trailingAxis) {
    case 0 : 
        return node[/* style */0][/* marginRight */14];
    case 1 : 
        return node[/* style */0][/* marginLeft */12];
    case 2 : 
        return node[/* style */0][/* marginBottom */15];
    case 3 : 
        return node[/* style */0][/* marginTop */13];
    
  }
}

function styleTrailingBorderForAxis(node, trailingAxis) {
  switch (trailingAxis) {
    case 0 : 
        return node[/* style */0][/* borderRight */38];
    case 1 : 
        return node[/* style */0][/* borderLeft */36];
    case 2 : 
        return node[/* style */0][/* borderBottom */39];
    case 3 : 
        return node[/* style */0][/* borderTop */37];
    
  }
}

function setDimLayoutDimensionForAxis(node, axis, value) {
  if (axis >= 2) {
    node[/* layout */1][/* height */5] = value;
    return /* () */0;
  } else {
    node[/* layout */1][/* width */4] = value;
    return /* () */0;
  }
}

function setLayoutMeasuredDimensionForAxis(node, axis, value) {
  if (axis >= 2) {
    node[/* layout */1][/* measuredHeight */19] = value;
    return /* () */0;
  } else {
    node[/* layout */1][/* measuredWidth */18] = value;
    return /* () */0;
  }
}

function setLayoutLeadingPositionForAxis(node, axis, value) {
  switch (axis) {
    case 0 : 
        node[/* layout */1][/* left */0] = value;
        return /* () */0;
    case 1 : 
        node[/* layout */1][/* right */2] = value;
        return /* () */0;
    case 2 : 
        node[/* layout */1][/* top */1] = value;
        return /* () */0;
    case 3 : 
        node[/* layout */1][/* bottom */3] = value;
        return /* () */0;
    
  }
}

function setLayoutTrailingPositionForAxis(node, axis, value) {
  switch (axis) {
    case 0 : 
        node[/* layout */1][/* right */2] = value;
        return /* () */0;
    case 1 : 
        node[/* layout */1][/* left */0] = value;
        return /* () */0;
    case 2 : 
        node[/* layout */1][/* bottom */3] = value;
        return /* () */0;
    case 3 : 
        node[/* layout */1][/* top */1] = value;
        return /* () */0;
    
  }
}

function resolveDirection(node, parentDirection) {
  var direction = node[/* style */0][/* direction */0];
  if (direction === /* CssDirectionInherit */1) {
    var match = +(parentDirection === /* CssDirectionInherit */1);
    if (match !== 0) {
      return /* CssDirectionLtr */2;
    } else {
      return parentDirection;
    }
  } else {
    return direction;
  }
}

function resolveAxis(flex_direction, direction) {
  if (direction === /* CssDirectionRtl */3) {
    if (flex_direction) {
      if (flex_direction === /* CssFlexDirectionRowReverse */1) {
        return /* CssFlexDirectionRow */0;
      } else {
        return flex_direction;
      }
    } else {
      return /* CssFlexDirectionRowReverse */1;
    }
  } else {
    return flex_direction;
  }
}

function isRowDirection(flexDirection) {
  if (flexDirection) {
    return +(flexDirection === /* CssFlexDirectionRowReverse */1);
  } else {
    return /* true */1;
  }
}

function isColumnDirection(flexDirection) {
  if (flexDirection === /* CssFlexDirectionColumn */2) {
    return /* true */1;
  } else {
    return +(flexDirection === /* CssFlexDirectionColumnReverse */3);
  }
}

function getCrossFlexDirection(flex_direction, direction) {
  var match = isColumnDirection(flex_direction);
  if (match !== 0) {
    return resolveAxis(/* CssFlexDirectionRow */0, direction);
  } else {
    return /* CssFlexDirectionColumn */2;
  }
}

function isFlex(node) {
  if (node[/* style */0][/* positionType */6]) {
    return /* false */0;
  } else if (node[/* style */0][/* flexGrow */9] !== LayoutValue.zero) {
    return /* true */1;
  } else {
    return +(node[/* style */0][/* flexShrink */10] !== LayoutValue.zero);
  }
}

function getLeadingMargin(node, axis) {
  if (isRowDirection(axis) && !LayoutValue.isUndefined(node[/* style */0][/* marginStart */16])) {
    return node[/* style */0][/* marginStart */16];
  } else {
    return styleLeadingMarginForAxis(node, axis);
  }
}

function getTrailingMargin(node, axis) {
  if (isRowDirection(axis) && !LayoutValue.isUndefined(node[/* style */0][/* marginEnd */17])) {
    return node[/* style */0][/* marginEnd */17];
  } else {
    return styleTrailingMarginForAxis(node, axis);
  }
}

function getLeadingPadding(node, axis) {
  if (isRowDirection(axis) && !LayoutValue.isUndefined(node[/* style */0][/* paddingStart */34]) && node[/* style */0][/* paddingStart */34] >= LayoutValue.zero) {
    return node[/* style */0][/* paddingStart */34];
  } else {
    var leadingPadding = styleLeadingPaddingForAxis(node, axis);
    if (leadingPadding >= LayoutValue.zero) {
      return leadingPadding;
    } else {
      return LayoutValue.zero;
    }
  }
}

function getTrailingPadding(node, axis) {
  if (isRowDirection(axis) && !LayoutValue.isUndefined(node[/* style */0][/* paddingEnd */35]) && node[/* style */0][/* paddingEnd */35] >= LayoutValue.zero) {
    return node[/* style */0][/* paddingEnd */35];
  } else {
    var trailingPadding = styleTrailingPaddingForAxis(node, axis);
    var match = +(trailingPadding >= LayoutValue.zero);
    if (match !== 0) {
      return trailingPadding;
    } else {
      return LayoutValue.zero;
    }
  }
}

function getLeadingBorder(node, axis) {
  if (isRowDirection(axis) && !LayoutValue.isUndefined(node[/* style */0][/* borderStart */40]) && node[/* style */0][/* borderStart */40] >= LayoutValue.zero) {
    return node[/* style */0][/* borderStart */40];
  } else {
    var leadingBorder = styleLeadingBorderForAxis(node, axis);
    var match = +(leadingBorder >= LayoutValue.zero);
    if (match !== 0) {
      return leadingBorder;
    } else {
      return LayoutValue.zero;
    }
  }
}

function getTrailingBorder(node, axis) {
  if (isRowDirection(axis) && !LayoutValue.isUndefined(node[/* style */0][/* borderEnd */41]) && node[/* style */0][/* borderEnd */41] >= LayoutValue.zero) {
    return node[/* style */0][/* borderEnd */41];
  } else {
    var trailingBorder = styleTrailingBorderForAxis(node, axis);
    var match = +(trailingBorder >= LayoutValue.zero);
    if (match !== 0) {
      return trailingBorder;
    } else {
      return LayoutValue.zero;
    }
  }
}

function getLeadingPaddingAndBorder(node, axis) {
  return LayoutValue.$plus$dot(getLeadingPadding(node, axis), getLeadingBorder(node, axis));
}

function getTrailingPaddingAndBorder(node, axis) {
  return LayoutValue.$plus$dot(getTrailingPadding(node, axis), getTrailingBorder(node, axis));
}

function getMarginAxis(node, axis) {
  return LayoutValue.$plus$dot(getLeadingMargin(node, axis), getTrailingMargin(node, axis));
}

function getPaddingAndBorderAxis(node, axis) {
  return LayoutValue.$plus$dot(getLeadingPaddingAndBorder(node, axis), getTrailingPaddingAndBorder(node, axis));
}

function getAlignItem(node, child) {
  var match = +(child[/* style */0][/* alignSelf */5] !== /* CssAlignAuto */0);
  if (match !== 0) {
    return child[/* style */0][/* alignSelf */5];
  } else {
    return node[/* style */0][/* alignItems */4];
  }
}

function getDimWithMargin(node, axis) {
  return LayoutValue.$plus$dot(LayoutValue.$plus$dot(layoutMeasuredDimensionForAxis(node, axis), getLeadingMargin(node, axis)), getTrailingMargin(node, axis));
}

function isStyleDimDefined(node, axis) {
  var value = styleDimensionForAxis(node, axis);
  if (LayoutValue.isUndefined(value)) {
    return /* false */0;
  } else {
    return +(value >= LayoutValue.zero);
  }
}

function isLayoutDimDefined(node, axis) {
  var value = layoutMeasuredDimensionForAxis(node, axis);
  if (LayoutValue.isUndefined(value)) {
    return /* false */0;
  } else {
    return +(value >= LayoutValue.zero);
  }
}

function isLeadingPosDefinedWithFallback(node, axis) {
  if (isRowDirection(axis) && !LayoutValue.isUndefined(node[/* style */0][/* start */28])) {
    return /* true */1;
  } else {
    return 1 - LayoutValue.isUndefined(styleLeadingPositionForAxis(node, axis));
  }
}

function isTrailingPosDefinedWithFallback(node, axis) {
  if (isRowDirection(axis) && !LayoutValue.isUndefined(node[/* style */0][/* endd */29])) {
    return /* true */1;
  } else {
    return 1 - LayoutValue.isUndefined(styleTrailingPositionForAxis(node, axis));
  }
}

function getLeadingPositionWithFallback(node, axis) {
  if (isRowDirection(axis) && !LayoutValue.isUndefined(node[/* style */0][/* start */28])) {
    return node[/* style */0][/* start */28];
  } else {
    return styleLeadingPositionForAxisOrZero(node, axis);
  }
}

function getTrailingPositionWithFallback(node, axis) {
  if (isRowDirection(axis) && !LayoutValue.isUndefined(node[/* style */0][/* endd */29])) {
    return node[/* style */0][/* endd */29];
  } else {
    return styleTrailingPositionForAxisOrZero(node, axis);
  }
}

function normalizePosition(position) {
  var match = 1 - LayoutValue.isUndefined(position);
  if (match !== 0) {
    return position;
  } else {
    return LayoutValue.zero;
  }
}

function boundAxisWithinMinAndMax(node, axis, value) {
  var match = isColumnDirection(axis) ? /* tuple */[
      node[/* style */0][/* minHeight */21],
      node[/* style */0][/* maxHeight */23]
    ] : (
      isRowDirection(axis) ? /* tuple */[
          node[/* style */0][/* minWidth */20],
          node[/* style */0][/* maxWidth */22]
        ] : /* tuple */[
          LayoutValue.cssUndefined,
          LayoutValue.cssUndefined
        ]
    );
  var max = match[1];
  var min = match[0];
  var nextBoundValue = !LayoutValue.isUndefined(max) && max >= LayoutValue.zero && value > max ? max : value;
  if (!LayoutValue.isUndefined(min) && min >= LayoutValue.zero && nextBoundValue < min) {
    return min;
  } else {
    return nextBoundValue;
  }
}

function fminf(a, b) {
  var match = LayoutValue.isUndefined(b) || +(a < b);
  if (match !== 0) {
    return a;
  } else {
    return b;
  }
}

function fmaxf(a, b) {
  var match = LayoutValue.isUndefined(b) || +(a > b);
  if (match !== 0) {
    return a;
  } else {
    return b;
  }
}

function boundAxis(node, axis, value) {
  return fmaxf(boundAxisWithinMinAndMax(node, axis, value), getPaddingAndBorderAxis(node, axis));
}

function setTrailingPosition(node, child, axis) {
  var measuredChildDimensionForAxis = layoutMeasuredDimensionForAxis(child, axis);
  var childLayoutPosValueForAxis = layoutPosPositionForAxis(child, axis);
  var nextValue = LayoutValue.$neg$dot(LayoutValue.$neg$dot(layoutMeasuredDimensionForAxis(node, axis), measuredChildDimensionForAxis), childLayoutPosValueForAxis);
  return setLayoutTrailingPositionForAxis(child, axis, nextValue);
}

function getRelativePosition(node, axis) {
  if (isLeadingPosDefinedWithFallback(node, axis)) {
    return getLeadingPositionWithFallback(node, axis);
  } else {
    return LayoutValue.$tilde$neg$dot(getTrailingPositionWithFallback(node, axis));
  }
}

function setPosition(node, direction) {
  var mainAxis = resolveAxis(node[/* style */0][/* flexDirection */1], direction);
  var crossAxis = getCrossFlexDirection(mainAxis, direction);
  setLayoutLeadingPositionForAxis(node, mainAxis, LayoutValue.$plus$dot(getLeadingMargin(node, mainAxis), getRelativePosition(node, mainAxis)));
  setLayoutTrailingPositionForAxis(node, mainAxis, LayoutValue.$plus$dot(getTrailingMargin(node, mainAxis), getRelativePosition(node, mainAxis)));
  setLayoutLeadingPositionForAxis(node, crossAxis, LayoutValue.$plus$dot(getLeadingMargin(node, crossAxis), getRelativePosition(node, crossAxis)));
  return setLayoutTrailingPositionForAxis(node, crossAxis, LayoutValue.$plus$dot(getTrailingMargin(node, crossAxis), getRelativePosition(node, crossAxis)));
}

function cssNodeStyleGetFlex(node) {
  if (node[/* style */0][/* flexGrow */9] > LayoutValue.zero) {
    return node[/* style */0][/* flexGrow */9];
  } else if (node[/* style */0][/* flexShrink */10] > LayoutValue.zero) {
    return LayoutValue.$tilde$neg$dot(node[/* style */0][/* flexShrink */10]);
  } else {
    return LayoutValue.zero;
  }
}

var positive_flex_is_auto = /* false */0;

var gCurrentGenerationCount = 0;

var failOnDummyMeasure = /* true */1;

var layoutLeadingPositionForAxis = layoutPosPositionForAxis;

export {
  positive_flex_is_auto              ,
  gCurrentGenerationCount            ,
  failOnDummyMeasure                 ,
  dummyMeasure                       ,
  dummyIsDirty                       ,
  dummyCachedMeasurement             ,
  defaultStyle                       ,
  theNullNode                        ,
  createNode                         ,
  layoutMeasuredDimensionForAxis     ,
  layoutPosPositionForAxis           ,
  layoutLeadingPositionForAxis       ,
  layoutTrailingPositionForAxis      ,
  styleDimensionForAxis              ,
  styleLeadingPositionForAxis        ,
  styleLeadingPositionForAxisOrZero  ,
  styleLeadingPaddingForAxis         ,
  styleLeadingMarginForAxis          ,
  styleLeadingBorderForAxis          ,
  styleTrailingPositionForAxis       ,
  styleTrailingPositionForAxisOrZero ,
  styleTrailingPaddingForAxis        ,
  styleTrailingMarginForAxis         ,
  styleTrailingBorderForAxis         ,
  setDimLayoutDimensionForAxis       ,
  setLayoutMeasuredDimensionForAxis  ,
  setLayoutLeadingPositionForAxis    ,
  setLayoutTrailingPositionForAxis   ,
  resolveDirection                   ,
  resolveAxis                        ,
  isRowDirection                     ,
  isColumnDirection                  ,
  getCrossFlexDirection              ,
  isFlex                             ,
  getLeadingMargin                   ,
  getTrailingMargin                  ,
  getLeadingPadding                  ,
  getTrailingPadding                 ,
  getLeadingBorder                   ,
  getTrailingBorder                  ,
  getLeadingPaddingAndBorder         ,
  getTrailingPaddingAndBorder        ,
  getMarginAxis                      ,
  getPaddingAndBorderAxis            ,
  getAlignItem                       ,
  getDimWithMargin                   ,
  isStyleDimDefined                  ,
  isLayoutDimDefined                 ,
  isLeadingPosDefinedWithFallback    ,
  isTrailingPosDefinedWithFallback   ,
  getLeadingPositionWithFallback     ,
  getTrailingPositionWithFallback    ,
  normalizePosition                  ,
  boundAxisWithinMinAndMax           ,
  fminf                              ,
  fmaxf                              ,
  boundAxis                          ,
  setTrailingPosition                ,
  getRelativePosition                ,
  setPosition                        ,
  cssNodeStyleGetFlex                ,
  
}
/* No side effect */
