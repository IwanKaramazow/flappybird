// Generated by BUCKLESCRIPT VERSION 1.6.1, PLEASE EDIT WITH CARE
'use strict';

var List       = require("bs-platform/lib/js/list");
var $$Array    = require("bs-platform/lib/js/array");
var Curry      = require("bs-platform/lib/js/curry");
var Common     = require("./common");
var Random     = require("bs-platform/lib/js/random");
var Caml_array = require("bs-platform/lib/js/caml_array");
var Caml_int32 = require("bs-platform/lib/js/caml_int32");
var Pervasives = require("bs-platform/lib/js/pervasives");

var pi = 4.0 * Math.atan(1.0);

var two_pi = 2.0 * pi;

var half_pi = 0.5 * pi;

var quarter_pi = 0.25 * pi;

var PConstants_000 = /* white : record */[
  /* r */255,
  /* g */255,
  /* b */255
];

var PConstants_001 = /* black : record */[
  /* r */0,
  /* g */0,
  /* b */0
];

var PConstants = /* module */[
  PConstants_000,
  PConstants_001,
  /* pi */pi,
  /* two_pi */two_pi,
  /* half_pi */half_pi,
  /* quarter_pi */quarter_pi,
  /* tau */two_pi
];

var lookup_table = [/* int array */[]];

function color(r, g, b) {
  return /* record */[
          /* r */r,
          /* g */g,
          /* b */b
        ];
}

function round(i) {
  return Math.floor(i + 0.5);
}

function sqrt(prim) {
  return Math.sqrt(prim);
}

function ceil(prim) {
  return Math.ceil(prim);
}

function exp(prim) {
  return Math.exp(prim);
}

function log(prim) {
  return Math.log(prim);
}

function sq(x) {
  return Caml_int32.imul(x, x);
}

function pow(a, n) {
  if (n !== 0) {
    if (n !== 1) {
      var b = pow(a, n / 2 | 0);
      return Caml_int32.imul(Caml_int32.imul(b, b), n % 2 ? a : 1);
    } else {
      return a;
    }
  } else {
    return 1;
  }
}

function constrain(amt, low, high) {
  return Pervasives.max(Pervasives.min(amt, high), low);
}

function remapf(value, istart, istop, ostart, ostop) {
  return ostart + (ostop - ostart) * ((value - istart) / (istop - istart));
}

function remap(x, a, b, c, d) {
  return remapf(x, a, b, c, d) | 0;
}

function norm(value, low, high) {
  return remapf(value, low, high, 0, 1);
}

function randomf(low, high) {
  return Random.$$float(high - low) + low;
}

function random(low, high) {
  return Random.$$int(high - low | 0) + low | 0;
}

var randomSeed = Random.init;

function randomGaussian() {
  var u1 = 0.0;
  var u2 = 0.0;
  while(u1 <= Pervasives.min_float) {
    u1 = Random.$$float(1.0);
    u2 = Random.$$float(1.0);
  };
  return Math.sqrt(-2.0 * Math.log(u1)) * Math.cos(two_pi * u2);
}

function lerpf(start, stop, amt) {
  return remapf(amt, 0, 1, start, stop);
}

function lerp(start, stop, amt) {
  return lerpf(start, stop, amt) | 0;
}

function distf(param, param$1) {
  var dx = param$1[0] - param[0];
  var dy = param$1[1] - param[1];
  return Math.sqrt(dx * dx + dy * dy);
}

function dist(param, param$1) {
  return distf(/* tuple */[
              param[0],
              param[1]
            ], /* tuple */[
              param$1[0],
              param$1[1]
            ]);
}

function mag(vec) {
  return dist(/* tuple */[
              0,
              0
            ], vec);
}

function lerpColor(low, high, amt) {
  return /* record */[
          /* r */lerp(low[/* r */0], high[/* r */0], amt),
          /* g */lerp(low[/* g */1], high[/* g */1], amt),
          /* b */lerp(low[/* b */2], high[/* b */2], amt)
        ];
}

function acos(prim) {
  return Math.acos(prim);
}

function asin(prim) {
  return Math.asin(prim);
}

function atan(prim) {
  return Math.atan(prim);
}

function atan2(prim, prim$1) {
  return Math.atan2(prim, prim$1);
}

function cos(prim) {
  return Math.cos(prim);
}

function degrees(x) {
  return 180.0 / pi * x;
}

function radians(x) {
  return pi / 180.0 * x;
}

function sin(prim) {
  return Math.sin(prim);
}

function tan(prim) {
  return Math.tan(prim);
}

function noise(x, y, z) {
  var p = lookup_table[0];
  var fade = function (t) {
    return t * t * t * (t * (t * 6.0 - 15.0) + 10.0);
  };
  var grad = function (hash, x, y, z) {
    var match = hash & 15;
    if (match > 15 || match < 0) {
      return 0.0;
    } else {
      switch (match) {
        case 0 : 
            return x + y;
        case 1 : 
            return -x + y;
        case 2 : 
            return x - y;
        case 3 : 
            return -x - y;
        case 4 : 
            return x + z;
        case 5 : 
            return -x + z;
        case 6 : 
            return x - z;
        case 7 : 
            return -x - z;
        case 8 : 
            return y + z;
        case 10 : 
            return y - z;
        case 12 : 
            return y + x;
        case 9 : 
        case 13 : 
            return -y + z;
        case 14 : 
            return y - x;
        case 11 : 
        case 15 : 
            return -y - z;
        
      }
    }
  };
  var xi = x & 255;
  var yi = y & 255;
  var zi = z & 255;
  var xf = x - Math.floor(x);
  var yf = y - Math.floor(y);
  var zf = z - Math.floor(z);
  var u = fade(xf);
  var v = fade(yf);
  var w = fade(zf);
  var aaa = Caml_array.caml_array_get(p, Caml_array.caml_array_get(p, Caml_array.caml_array_get(p, xi) + yi | 0) + zi | 0);
  var aba = Caml_array.caml_array_get(p, Caml_array.caml_array_get(p, Caml_array.caml_array_get(p, xi) + (yi + 1 | 0) | 0) + zi | 0);
  var aab = Caml_array.caml_array_get(p, Caml_array.caml_array_get(p, Caml_array.caml_array_get(p, xi) + yi | 0) + (zi + 1 | 0) | 0);
  var abb = Caml_array.caml_array_get(p, Caml_array.caml_array_get(p, Caml_array.caml_array_get(p, xi) + (yi + 1 | 0) | 0) + (zi + 1 | 0) | 0);
  var baa = Caml_array.caml_array_get(p, Caml_array.caml_array_get(p, Caml_array.caml_array_get(p, xi + 1 | 0) + yi | 0) + zi | 0);
  var bba = Caml_array.caml_array_get(p, Caml_array.caml_array_get(p, Caml_array.caml_array_get(p, xi + 1 | 0) + (yi + 1 | 0) | 0) + zi | 0);
  var bab = Caml_array.caml_array_get(p, Caml_array.caml_array_get(p, Caml_array.caml_array_get(p, xi + 1 | 0) + yi | 0) + (zi + 1 | 0) | 0);
  var bbb = Caml_array.caml_array_get(p, Caml_array.caml_array_get(p, Caml_array.caml_array_get(p, xi + 1 | 0) + (yi + 1 | 0) | 0) + (zi + 1 | 0) | 0);
  var x1 = lerpf(grad(aaa, xf, yf, zf), grad(baa, xf - 1.0, yf, zf), u);
  var x2 = lerpf(grad(aba, xf, yf - 1.0, zf), grad(bba, xf - 1.0, yf - 1.0, zf), u);
  var y1 = lerpf(x1, x2, v);
  var x1$1 = lerpf(grad(aab, xf, yf, zf - 1.0), grad(bab, xf - 1.0, yf, zf - 1.0), u);
  var x2$1 = lerpf(grad(abb, xf, yf - 1.0, zf - 1.0), grad(bbb, xf - 1.0, yf - 1.0, zf - 1.0), u);
  var y2 = lerpf(x1$1, x2$1, v);
  return (lerpf(y1, y2, w) + 1.0) / 2.0;
}

function shuffle(array) {
  var array$1 = $$Array.copy(array);
  var length = array$1.length;
  for(var i = 0; i <= 255; ++i){
    var j = Random.$$int(length - i | 0);
    var tmp = Caml_array.caml_array_get(array$1, i);
    Caml_array.caml_array_set(array$1, i, Caml_array.caml_array_get(array$1, i + j | 0));
    Caml_array.caml_array_set(array$1, i + j | 0, tmp);
  }
  return array$1;
}

function noiseSeed(seed) {
  var state = Random.get_state(/* () */0);
  Random.init(seed);
  var array = Caml_array.caml_make_vect(256, 0);
  var array$1 = $$Array.mapi(function (i, _) {
        return i;
      }, array);
  var array$2 = shuffle(array$1);
  var double_array = $$Array.append(array$2, array$2);
  lookup_table[0] = double_array;
  return Random.set_state(state);
}

function split(str, sep) {
  var _stream = Curry._1(Common.Stream[/* create */7], str);
  var sep$1 = sep;
  var _accstr = "";
  var _acc = /* [] */0;
  while(true) {
    var acc = _acc;
    var accstr = _accstr;
    var stream = _stream;
    var match = Curry._1(Common.Stream[/* peekch */1], stream);
    if (match) {
      var c = match[0];
      if (c === sep$1) {
        _acc = /* :: */[
          accstr,
          acc
        ];
        _accstr = "";
        _stream = Curry._1(Common.Stream[/* popch */2], stream);
        continue ;
        
      } else {
        _accstr = Common.append_char(accstr, c);
        _stream = Curry._1(Common.Stream[/* popch */2], stream);
        continue ;
        
      }
    } else {
      return List.rev(/* :: */[
                  accstr,
                  acc
                ]);
    }
  };
}

var PUtils = /* module */[
  /* lookup_table */lookup_table,
  /* color */color,
  /* round */round,
  /* max */Pervasives.max,
  /* min */Pervasives.min,
  /* sqrt */sqrt,
  /* abs */Pervasives.abs,
  /* ceil */ceil,
  /* exp */exp,
  /* log */log,
  /* sq */sq,
  /* pow */pow,
  /* constrain */constrain,
  /* remapf */remapf,
  /* remap */remap,
  /* norm */norm,
  /* randomf */randomf,
  /* random */random,
  /* randomSeed */randomSeed,
  /* randomGaussian */randomGaussian,
  /* lerpf */lerpf,
  /* lerp */lerp,
  /* distf */distf,
  /* dist */dist,
  /* mag */mag,
  /* lerpColor */lerpColor,
  /* acos */acos,
  /* asin */asin,
  /* atan */atan,
  /* atan2 */atan2,
  /* cos */cos,
  /* degrees */degrees,
  /* radians */radians,
  /* sin */sin,
  /* tan */tan,
  /* noise */noise,
  /* shuffle */shuffle,
  /* noiseSeed */noiseSeed,
  /* split */split
];

exports.PConstants = PConstants;
exports.PUtils     = PUtils;
/* pi Not a pure module */
