// Generated by BUCKLESCRIPT VERSION 1.6.1, PLEASE EDIT WITH CARE
'use strict';

var Curry        = require("bs-platform/lib/js/curry");
var Utils        = require("./utils");
var Common       = require("./common");
var Matrix       = require("./matrix");
var Shaders      = require("./shaders");
var WGLWebgl     = require("reasongl-web/lib/js/src/wGLWebgl");
var Caml_int32   = require("bs-platform/lib/js/caml_int32");
var Pervasives   = require("bs-platform/lib/js/pervasives");
var RGLConstants = require("reasongl-interface/lib/js/src/rGLConstants");

function getProgram(gl, vertexShaderSource, fragmentShaderSource) {
  var vertexShader = Curry._2(WGLWebgl.Gl[/* createShader */7], gl, RGLConstants.vertex_shader);
  Curry._3(WGLWebgl.Gl[/* shaderSource */10], gl, vertexShader, vertexShaderSource);
  Curry._2(WGLWebgl.Gl[/* compileShader */11], gl, vertexShader);
  var compiledCorrectly = +(Curry._3(WGLWebgl.Gl[/* getShaderParameter */47], gl, vertexShader, /* Compile_status */1) === 1);
  if (compiledCorrectly) {
    var fragmentShader = Curry._2(WGLWebgl.Gl[/* createShader */7], gl, RGLConstants.fragment_shader);
    Curry._3(WGLWebgl.Gl[/* shaderSource */10], gl, fragmentShader, fragmentShaderSource);
    Curry._2(WGLWebgl.Gl[/* compileShader */11], gl, fragmentShader);
    var compiledCorrectly$1 = +(Curry._3(WGLWebgl.Gl[/* getShaderParameter */47], gl, fragmentShader, /* Compile_status */1) === 1);
    if (compiledCorrectly$1) {
      var program = Curry._1(WGLWebgl.Gl[/* createProgram */6], gl);
      Curry._3(WGLWebgl.Gl[/* attachShader */8], gl, program, vertexShader);
      Curry._2(WGLWebgl.Gl[/* deleteShader */9], gl, vertexShader);
      Curry._3(WGLWebgl.Gl[/* attachShader */8], gl, program, fragmentShader);
      Curry._2(WGLWebgl.Gl[/* deleteShader */9], gl, fragmentShader);
      Curry._2(WGLWebgl.Gl[/* linkProgram */12], gl, program);
      var linkedCorrectly = +(Curry._3(WGLWebgl.Gl[/* getProgramParameter */46], gl, program, /* Link_status */1) === 1);
      if (linkedCorrectly) {
        return /* Some */[program];
      } else {
        console.log("Linking error: " + Curry._2(WGLWebgl.Gl[/* getProgramInfoLog */49], gl, program));
        return /* None */0;
      }
    } else {
      console.log("Fragment shader error: " + Curry._2(WGLWebgl.Gl[/* getShaderInfoLog */48], gl, fragmentShader));
      return /* None */0;
    }
  } else {
    console.log("Vertex shader error: " + Curry._2(WGLWebgl.Gl[/* getShaderInfoLog */48], gl, vertexShader));
    return /* None */0;
  }
}

function createCanvas($$window, height, width) {
  Curry._3(WGLWebgl.Gl[/* Window */2][/* setWindowSize */3], $$window, width, height);
  var gl = Curry._1(WGLWebgl.Gl[/* Window */2][/* getContext */5], $$window);
  Curry._5(WGLWebgl.Gl[/* viewport */38], gl, -1, -1, width, height);
  Curry._5(WGLWebgl.Gl[/* clearColor */5], gl, 0, 0, 0, 1);
  Curry._2(WGLWebgl.Gl[/* clear */39], gl, RGLConstants.color_buffer_bit | RGLConstants.depth_buffer_bit);
  var camera = /* record */[/* projectionMatrix */Curry._1(WGLWebgl.Gl[/* Mat4 */44][/* create */1], /* () */0)];
  var vertexBuffer = Curry._1(WGLWebgl.Gl[/* createBuffer */14], gl);
  var elementBuffer = Curry._1(WGLWebgl.Gl[/* createBuffer */14], gl);
  var match = getProgram(gl, Shaders.vertexShaderSource, Shaders.fragmentShaderSource);
  var program = match ? match[0] : Pervasives.failwith("Could not create the program and/or the shaders. Aborting.");
  Curry._2(WGLWebgl.Gl[/* useProgram */13], gl, program);
  var aVertexPosition = Curry._3(WGLWebgl.Gl[/* getAttribLocation */41], gl, program, "aVertexPosition");
  Curry._2(WGLWebgl.Gl[/* enableVertexAttribArray */42], gl, aVertexPosition);
  var aVertexColor = Curry._3(WGLWebgl.Gl[/* getAttribLocation */41], gl, program, "aVertexColor");
  Curry._2(WGLWebgl.Gl[/* enableVertexAttribArray */42], gl, aVertexColor);
  var pMatrixUniform = Curry._3(WGLWebgl.Gl[/* getUniformLocation */40], gl, program, "uPMatrix");
  Curry._3(WGLWebgl.Gl[/* uniformMatrix4fv */45], gl, pMatrixUniform, camera[/* projectionMatrix */0]);
  var aTextureCoord = Curry._3(WGLWebgl.Gl[/* getAttribLocation */41], gl, program, "aTextureCoord");
  Curry._2(WGLWebgl.Gl[/* enableVertexAttribArray */42], gl, aTextureCoord);
  var texture = Curry._1(WGLWebgl.Gl[/* createTexture */16], gl);
  Curry._2(WGLWebgl.Gl[/* activeTexture */17], gl, RGLConstants.texture0);
  Curry._3(WGLWebgl.Gl[/* bindTexture */18], gl, RGLConstants.texture_2d, texture);
  var uSampler = Curry._3(WGLWebgl.Gl[/* getUniformLocation */40], gl, program, "uSampler");
  Curry.app(WGLWebgl.Gl[/* texImage2D */32], [
        gl,
        RGLConstants.texture_2d,
        0,
        RGLConstants.rgba,
        1,
        1,
        RGLConstants.rgba,
        RGLConstants.unsigned_byte,
        Curry._1(WGLWebgl.Gl[/* toTextureData */20], /* int array */[
              0,
              0,
              0,
              0
            ])
      ]);
  Curry._4(WGLWebgl.Gl[/* texParameteri */19], gl, RGLConstants.texture_2d, RGLConstants.texture_mag_filter, RGLConstants.linear);
  Curry._4(WGLWebgl.Gl[/* texParameteri */19], gl, RGLConstants.texture_2d, RGLConstants.texture_min_filter, RGLConstants.linear_mipmap_nearest);
  Curry._2(WGLWebgl.Gl[/* enable */21], gl, RGLConstants.blend);
  Curry._3(WGLWebgl.Gl[/* blendFunc */23], gl, RGLConstants.src_alpha, RGLConstants.one_minus_src_alpha);
  Curry._7(WGLWebgl.Gl[/* Mat4 */44][/* ortho */6], camera[/* projectionMatrix */0], 0, width, height, 0, 0, 1);
  return /* record */[
          /* camera */camera,
          /* window */$$window,
          /* gl */gl,
          /* vertexBuffer */vertexBuffer,
          /* elementBuffer */elementBuffer,
          /* aVertexColor */aVertexColor,
          /* aTextureCoord */aTextureCoord,
          /* aVertexPosition */aVertexPosition,
          /* pMatrixUniform */pMatrixUniform,
          /* uSampler */uSampler,
          /* batch : record */[
            /* vertexArray */Curry._2(WGLWebgl.Gl[/* Bigarray */36][/* create */0], /* Float32 */1, Caml_int32.imul(Common.circularBufferSize, Common.vertexSize)),
            /* elementArray */Curry._2(WGLWebgl.Gl[/* Bigarray */36][/* create */0], /* Uint16 */3, Common.circularBufferSize),
            /* vertexPtr */0,
            /* elementPtr */0,
            /* currTex : None */0,
            /* nullTex */texture
          ],
          /* keyboard : record */[/* keyCode : Nothing */65],
          /* mouse : record */[
            /* pos : tuple */[
              0,
              0
            ],
            /* prevPos : tuple */[
              0,
              0
            ],
            /* pressed : false */0
          ],
          /* style : record */[
            /* strokeColor : Some */[/* record */[
                /* r */0,
                /* g */0,
                /* b */0
              ]],
            /* strokeWeight */10,
            /* fillColor : Some */[/* record */[
                /* r */0,
                /* g */0,
                /* b */0
              ]]
          ],
          /* styleStack : [] */0,
          /* frame : record */[
            /* count */1,
            /* rate */10
          ],
          /* matrix */Matrix.createIdentity(/* () */0),
          /* matrixStack : [] */0,
          /* size : record */[
            /* height */height,
            /* width */width,
            /* resizeable : true */1
          ]
        ];
}

function drawGeometry(vertexArray, elementArray, mode, count, textureBuffer, env) {
  Curry._3(WGLWebgl.Gl[/* bindBuffer */15], env[/* gl */2], RGLConstants.array_buffer, env[/* vertexBuffer */3]);
  Curry._4(WGLWebgl.Gl[/* bufferData */37], env[/* gl */2], RGLConstants.array_buffer, vertexArray, RGLConstants.stream_draw);
  Curry._7(WGLWebgl.Gl[/* vertexAttribPointer */43], env[/* gl */2], env[/* aVertexPosition */7], 2, RGLConstants.float_, /* false */0, (Common.vertexSize << 2), 0);
  Curry._7(WGLWebgl.Gl[/* vertexAttribPointer */43], env[/* gl */2], env[/* aVertexColor */5], 4, RGLConstants.float_, /* false */0, (Common.vertexSize << 2), 8);
  Curry._7(WGLWebgl.Gl[/* vertexAttribPointer */43], env[/* gl */2], env[/* aTextureCoord */6], 2, RGLConstants.float_, /* false */0, (Common.vertexSize << 2), 24);
  Curry._3(WGLWebgl.Gl[/* uniform1i */33], env[/* gl */2], env[/* uSampler */9], 0);
  Curry._3(WGLWebgl.Gl[/* bindBuffer */15], env[/* gl */2], RGLConstants.element_array_buffer, env[/* elementBuffer */4]);
  Curry._4(WGLWebgl.Gl[/* bufferData */37], env[/* gl */2], RGLConstants.element_array_buffer, elementArray, RGLConstants.stream_draw);
  Curry._3(WGLWebgl.Gl[/* bindTexture */18], env[/* gl */2], RGLConstants.texture_2d, textureBuffer);
  return Curry._5(WGLWebgl.Gl[/* drawElements */52], env[/* gl */2], mode, count, RGLConstants.unsigned_short, 0);
}

function flushGlobalBatch(env) {
  if (env[/* batch */10][/* elementPtr */3] > 0) {
    var match = env[/* batch */10][/* currTex */4];
    var textureBuffer = match ? match[0] : env[/* batch */10][/* nullTex */5];
    drawGeometry(Curry._3(WGLWebgl.Gl[/* Bigarray */36][/* sub */5], env[/* batch */10][/* vertexArray */0], 0, env[/* batch */10][/* vertexPtr */2]), Curry._3(WGLWebgl.Gl[/* Bigarray */36][/* sub */5], env[/* batch */10][/* elementArray */1], 0, env[/* batch */10][/* elementPtr */3]), RGLConstants.triangles, env[/* batch */10][/* elementPtr */3], textureBuffer, env);
    env[/* batch */10][/* currTex */4] = /* None */0;
    env[/* batch */10][/* vertexPtr */2] = 0;
    env[/* batch */10][/* elementPtr */3] = 0;
    return /* () */0;
  } else {
    return 0;
  }
}

function maybeFlushBatch(env, texture, adding) {
  if ((env[/* batch */10][/* elementPtr */3] + adding | 0) >= Common.circularBufferSize || env[/* batch */10][/* elementPtr */3] > 0 && env[/* batch */10][/* currTex */4] !== texture) {
    return flushGlobalBatch(env);
  } else {
    return 0;
  }
}

function toColorFloat(i) {
  return i / 255;
}

function addRectToGlobalBatch(env, param, param$1, param$2, param$3, param$4) {
  maybeFlushBatch(env, /* None */0, 6);
  var set = WGLWebgl.Gl[/* Bigarray */36][/* set */4];
  var match_000 = param$4[/* r */0] / 255;
  var match_001 = param$4[/* g */1] / 255;
  var match_002 = param$4[/* b */2] / 255;
  var b = match_002;
  var g = match_001;
  var r = match_000;
  var i = env[/* batch */10][/* vertexPtr */2];
  var vertexArrayToMutate = env[/* batch */10][/* vertexArray */0];
  Curry._3(set, vertexArrayToMutate, i + 0 | 0, param[0]);
  Curry._3(set, vertexArrayToMutate, i + 1 | 0, param[1]);
  Curry._3(set, vertexArrayToMutate, i + 2 | 0, r);
  Curry._3(set, vertexArrayToMutate, i + 3 | 0, g);
  Curry._3(set, vertexArrayToMutate, i + 4 | 0, b);
  Curry._3(set, vertexArrayToMutate, i + 5 | 0, 1);
  Curry._3(set, vertexArrayToMutate, i + 6 | 0, 0.0);
  Curry._3(set, vertexArrayToMutate, i + 7 | 0, 0.0);
  Curry._3(set, vertexArrayToMutate, i + 8 | 0, param$1[0]);
  Curry._3(set, vertexArrayToMutate, i + 9 | 0, param$1[1]);
  Curry._3(set, vertexArrayToMutate, i + 10 | 0, r);
  Curry._3(set, vertexArrayToMutate, i + 11 | 0, g);
  Curry._3(set, vertexArrayToMutate, i + 12 | 0, b);
  Curry._3(set, vertexArrayToMutate, i + 13 | 0, 1);
  Curry._3(set, vertexArrayToMutate, i + 14 | 0, 0.0);
  Curry._3(set, vertexArrayToMutate, i + 15 | 0, 0.0);
  Curry._3(set, vertexArrayToMutate, i + 16 | 0, param$2[0]);
  Curry._3(set, vertexArrayToMutate, i + 17 | 0, param$2[1]);
  Curry._3(set, vertexArrayToMutate, i + 18 | 0, r);
  Curry._3(set, vertexArrayToMutate, i + 19 | 0, g);
  Curry._3(set, vertexArrayToMutate, i + 20 | 0, b);
  Curry._3(set, vertexArrayToMutate, i + 21 | 0, 1);
  Curry._3(set, vertexArrayToMutate, i + 22 | 0, 0.0);
  Curry._3(set, vertexArrayToMutate, i + 23 | 0, 0.0);
  Curry._3(set, vertexArrayToMutate, i + 24 | 0, param$3[0]);
  Curry._3(set, vertexArrayToMutate, i + 25 | 0, param$3[1]);
  Curry._3(set, vertexArrayToMutate, i + 26 | 0, r);
  Curry._3(set, vertexArrayToMutate, i + 27 | 0, g);
  Curry._3(set, vertexArrayToMutate, i + 28 | 0, b);
  Curry._3(set, vertexArrayToMutate, i + 29 | 0, 1);
  Curry._3(set, vertexArrayToMutate, i + 30 | 0, 0.0);
  Curry._3(set, vertexArrayToMutate, i + 31 | 0, 0.0);
  var ii = Caml_int32.div(i, Common.vertexSize);
  var j = env[/* batch */10][/* elementPtr */3];
  var elementArrayToMutate = env[/* batch */10][/* elementArray */1];
  Curry._3(set, elementArrayToMutate, j + 0 | 0, ii);
  Curry._3(set, elementArrayToMutate, j + 1 | 0, ii + 1 | 0);
  Curry._3(set, elementArrayToMutate, j + 2 | 0, ii + 2 | 0);
  Curry._3(set, elementArrayToMutate, j + 3 | 0, ii + 1 | 0);
  Curry._3(set, elementArrayToMutate, j + 4 | 0, ii + 2 | 0);
  Curry._3(set, elementArrayToMutate, j + 5 | 0, ii + 3 | 0);
  env[/* batch */10][/* vertexPtr */2] = i + (Common.vertexSize << 2) | 0;
  env[/* batch */10][/* elementPtr */3] = j + 6 | 0;
  return /* () */0;
}

function drawTriangleInternal(env, param, param$1, param$2, param$3) {
  maybeFlushBatch(env, /* None */0, 3);
  var set = WGLWebgl.Gl[/* Bigarray */36][/* set */4];
  var match_000 = param$3[/* r */0] / 255;
  var match_001 = param$3[/* g */1] / 255;
  var match_002 = param$3[/* b */2] / 255;
  var b = match_002;
  var g = match_001;
  var r = match_000;
  var i = env[/* batch */10][/* vertexPtr */2];
  var vertexArrayToMutate = env[/* batch */10][/* vertexArray */0];
  Curry._3(set, vertexArrayToMutate, i + 0 | 0, param[0]);
  Curry._3(set, vertexArrayToMutate, i + 1 | 0, param[1]);
  Curry._3(set, vertexArrayToMutate, i + 2 | 0, r);
  Curry._3(set, vertexArrayToMutate, i + 3 | 0, g);
  Curry._3(set, vertexArrayToMutate, i + 4 | 0, b);
  Curry._3(set, vertexArrayToMutate, i + 5 | 0, 1);
  Curry._3(set, vertexArrayToMutate, i + 6 | 0, 0.0);
  Curry._3(set, vertexArrayToMutate, i + 7 | 0, 0.0);
  Curry._3(set, vertexArrayToMutate, i + 8 | 0, param$1[0]);
  Curry._3(set, vertexArrayToMutate, i + 9 | 0, param$1[1]);
  Curry._3(set, vertexArrayToMutate, i + 10 | 0, r);
  Curry._3(set, vertexArrayToMutate, i + 11 | 0, g);
  Curry._3(set, vertexArrayToMutate, i + 12 | 0, b);
  Curry._3(set, vertexArrayToMutate, i + 13 | 0, 1);
  Curry._3(set, vertexArrayToMutate, i + 14 | 0, 0.0);
  Curry._3(set, vertexArrayToMutate, i + 15 | 0, 0.0);
  Curry._3(set, vertexArrayToMutate, i + 16 | 0, param$2[0]);
  Curry._3(set, vertexArrayToMutate, i + 17 | 0, param$2[1]);
  Curry._3(set, vertexArrayToMutate, i + 18 | 0, r);
  Curry._3(set, vertexArrayToMutate, i + 19 | 0, g);
  Curry._3(set, vertexArrayToMutate, i + 20 | 0, b);
  Curry._3(set, vertexArrayToMutate, i + 21 | 0, 1);
  Curry._3(set, vertexArrayToMutate, i + 22 | 0, 0.0);
  Curry._3(set, vertexArrayToMutate, i + 23 | 0, 0.0);
  var ii = Caml_int32.div(i, Common.vertexSize);
  var j = env[/* batch */10][/* elementPtr */3];
  var elementArrayToMutate = env[/* batch */10][/* elementArray */1];
  Curry._3(set, elementArrayToMutate, j + 0 | 0, ii);
  Curry._3(set, elementArrayToMutate, j + 1 | 0, ii + 1 | 0);
  Curry._3(set, elementArrayToMutate, j + 2 | 0, ii + 2 | 0);
  env[/* batch */10][/* vertexPtr */2] = i + Caml_int32.imul(3, Common.vertexSize) | 0;
  env[/* batch */10][/* elementPtr */3] = j + 3 | 0;
  return /* () */0;
}

function drawLineInternal(env, param, param$1, color) {
  var yy2 = param$1[1];
  var xx2 = param$1[0];
  var yy1 = param[1];
  var xx1 = param[0];
  var dx = xx2 - xx1;
  var dy = yy2 - yy1;
  var mag = Curry._2(Utils.PUtils[/* distf */22], /* tuple */[
        xx1,
        yy1
      ], /* tuple */[
        xx2,
        yy2
      ]);
  var radius = env[/* style */13][/* strokeWeight */1] / 2;
  var xthing = dy / mag * radius;
  var ything = -dx / mag * radius;
  var x1 = xx2 + xthing;
  var y1 = yy2 + ything;
  var x2 = xx1 + xthing;
  var y2 = yy1 + ything;
  var x3 = xx2 - xthing;
  var y3 = yy2 - ything;
  var x4 = xx1 - xthing;
  var y4 = yy1 - ything;
  return addRectToGlobalBatch(env, /* tuple */[
              x1,
              y1
            ], /* tuple */[
              x2,
              y2
            ], /* tuple */[
              x3,
              y3
            ], /* tuple */[
              x4,
              y4
            ], color);
}

function drawArcInternal(env, param, radx, rady, start, stop, isPie, matrix, param$1) {
  var yCenterOfCircle = param[1];
  var xCenterOfCircle = param[0];
  var noOfFans = ((radx + rady | 0) << 1) + 10 | 0;
  maybeFlushBatch(env, /* None */0, Caml_int32.imul(noOfFans - 3 | 0, 3) + 3 | 0);
  var pi = 4.0 * Math.atan(1.0);
  var anglePerFan = 2 * pi / noOfFans;
  var match_000 = param$1[/* r */0] / 255;
  var match_001 = param$1[/* g */1] / 255;
  var match_002 = param$1[/* b */2] / 255;
  var b = match_002;
  var g = match_001;
  var r = match_000;
  var verticesData = env[/* batch */10][/* vertexArray */0];
  var elementData = env[/* batch */10][/* elementArray */1];
  var set = WGLWebgl.Gl[/* Bigarray */36][/* set */4];
  var get = WGLWebgl.Gl[/* Bigarray */36][/* get */3];
  var vertexArrayOffset = env[/* batch */10][/* vertexPtr */2];
  var elementArrayOffset = env[/* batch */10][/* elementPtr */3];
  var start_i = isPie ? (start / anglePerFan | 0) - 2 | 0 : (start / anglePerFan | 0) - 1 | 0;
  var stop_i = (stop / anglePerFan | 0) - 1 | 0;
  for(var i = start_i; i <= stop_i; ++i){
    var param$2;
    if (isPie && (i - start_i | 0) === 0) {
      param$2 = /* tuple */[
        xCenterOfCircle,
        yCenterOfCircle
      ];
    } else {
      var angle = anglePerFan * (i + 1 | 0);
      param$2 = /* tuple */[
        xCenterOfCircle + Math.cos(angle) * radx,
        yCenterOfCircle + Math.sin(angle) * rady
      ];
    }
    var match = Matrix.matptmul(matrix, param$2);
    var ii = Caml_int32.imul(i - start_i | 0, Common.vertexSize) + vertexArrayOffset | 0;
    Curry._3(set, verticesData, ii + 0 | 0, match[0]);
    Curry._3(set, verticesData, ii + 1 | 0, match[1]);
    Curry._3(set, verticesData, ii + 2 | 0, r);
    Curry._3(set, verticesData, ii + 3 | 0, g);
    Curry._3(set, verticesData, ii + 4 | 0, b);
    Curry._3(set, verticesData, ii + 5 | 0, 1.0);
    Curry._3(set, verticesData, ii + 6 | 0, 0.0);
    Curry._3(set, verticesData, ii + 7 | 0, 0.0);
    if ((i - start_i | 0) < 3) {
      Curry._3(set, elementData, (i - start_i | 0) + elementArrayOffset | 0, Caml_int32.div(ii, Common.vertexSize));
    } else {
      var jj = (Caml_int32.imul((i - start_i | 0) - 3 | 0, 3) + elementArrayOffset | 0) + 3 | 0;
      Curry._3(set, elementData, jj, Caml_int32.div(vertexArrayOffset, Common.vertexSize));
      Curry._3(set, elementData, jj + 1 | 0, Curry._2(get, elementData, jj - 1 | 0));
      Curry._3(set, elementData, jj + 2 | 0, Caml_int32.div(ii, Common.vertexSize));
    }
  }
  env[/* batch */10][/* vertexPtr */2] = env[/* batch */10][/* vertexPtr */2] + Caml_int32.imul(noOfFans, Common.vertexSize) | 0;
  env[/* batch */10][/* elementPtr */3] = (env[/* batch */10][/* elementPtr */3] + Caml_int32.imul((stop_i - start_i | 0) - 3 | 0, 3) | 0) + 3 | 0;
  return /* () */0;
}

function drawEllipseInternal(env, center, radx, rady, matrix, c) {
  return drawArcInternal(env, center, radx, rady, 0, Utils.PConstants[/* tau */6], /* false */0, matrix, c);
}

function drawArcStroke(env, param, radx, rady, start, stop, isOpen, isPie, matrix, strokeColor, strokeWidth) {
  var yCenterOfCircle = param[1];
  var xCenterOfCircle = param[0];
  var match_000 = strokeColor[/* r */0] / 255;
  var match_001 = strokeColor[/* g */1] / 255;
  var match_002 = strokeColor[/* b */2] / 255;
  var b = match_002;
  var g = match_001;
  var r = match_000;
  var verticesData = env[/* batch */10][/* vertexArray */0];
  var elementData = env[/* batch */10][/* elementArray */1];
  var set = WGLWebgl.Gl[/* Bigarray */36][/* set */4];
  var noOfFans = ((radx + rady | 0) << 1) + 10 | 0;
  maybeFlushBatch(env, /* None */0, Caml_int32.imul(noOfFans - 3 | 0, 3) + 3 | 0);
  var pi = 4.0 * Math.atan(1.0);
  var anglePerFan = 2 * pi / noOfFans;
  var start_i = (start / anglePerFan | 0) - 1 | 0;
  var stop_i = (stop / anglePerFan | 0) - 1 | 0;
  var prevEl = /* None */0;
  var halfwidth = strokeWidth / 2;
  for(var i = start_i; i <= stop_i; ++i){
    var angle = anglePerFan * (i + 1 | 0);
    var param_000 = xCenterOfCircle + Math.cos(angle) * (radx - halfwidth);
    var param_001 = yCenterOfCircle + Math.sin(angle) * (rady - halfwidth);
    var param$1 = /* tuple */[
      param_000,
      param_001
    ];
    var match = Matrix.matptmul(matrix, param$1);
    var param_000$1 = xCenterOfCircle + Math.cos(angle) * (radx + halfwidth);
    var param_001$1 = yCenterOfCircle + Math.sin(angle) * (rady + halfwidth);
    var param$2 = /* tuple */[
      param_000$1,
      param_001$1
    ];
    var match$1 = Matrix.matptmul(matrix, param$2);
    var ii = env[/* batch */10][/* vertexPtr */2];
    Curry._3(set, verticesData, ii + 0 | 0, match[0]);
    Curry._3(set, verticesData, ii + 1 | 0, match[1]);
    Curry._3(set, verticesData, ii + 2 | 0, r);
    Curry._3(set, verticesData, ii + 3 | 0, g);
    Curry._3(set, verticesData, ii + 4 | 0, b);
    Curry._3(set, verticesData, ii + 5 | 0, 1.0);
    Curry._3(set, verticesData, ii + 6 | 0, 0.0);
    Curry._3(set, verticesData, ii + 7 | 0, 0.0);
    var ii$1 = ii + Common.vertexSize | 0;
    Curry._3(set, verticesData, ii$1 + 0 | 0, match$1[0]);
    Curry._3(set, verticesData, ii$1 + 1 | 0, match$1[1]);
    Curry._3(set, verticesData, ii$1 + 2 | 0, r);
    Curry._3(set, verticesData, ii$1 + 3 | 0, g);
    Curry._3(set, verticesData, ii$1 + 4 | 0, b);
    Curry._3(set, verticesData, ii$1 + 5 | 0, 1.0);
    Curry._3(set, verticesData, ii$1 + 6 | 0, 0.0);
    Curry._3(set, verticesData, ii$1 + 7 | 0, 0.0);
    env[/* batch */10][/* vertexPtr */2] = env[/* batch */10][/* vertexPtr */2] + (Common.vertexSize << 1) | 0;
    var currOuter = Caml_int32.div(ii$1, Common.vertexSize);
    var currInner = Caml_int32.div(ii$1, Common.vertexSize) - 1 | 0;
    var currEl = /* Some */[/* tuple */[
        currInner,
        currOuter
      ]];
    var match$2 = prevEl;
    if (match$2) {
      var match$3 = match$2[0];
      var prevInner = match$3[0];
      var elementArrayOffset = env[/* batch */10][/* elementPtr */3];
      Curry._3(set, elementData, elementArrayOffset, prevInner);
      Curry._3(set, elementData, elementArrayOffset + 1 | 0, match$3[1]);
      Curry._3(set, elementData, elementArrayOffset + 2 | 0, currOuter);
      Curry._3(set, elementData, elementArrayOffset + 3 | 0, currOuter);
      Curry._3(set, elementData, elementArrayOffset + 4 | 0, prevInner);
      Curry._3(set, elementData, elementArrayOffset + 5 | 0, currInner);
      env[/* batch */10][/* elementPtr */3] = env[/* batch */10][/* elementPtr */3] + 6 | 0;
      prevEl = currEl;
    } else {
      prevEl = currEl;
    }
  }
  if (isOpen) {
    return 0;
  } else {
    var param_000$2 = xCenterOfCircle + Math.cos(start) * radx;
    var param_001$2 = yCenterOfCircle + Math.sin(start) * rady;
    var param$3 = /* tuple */[
      param_000$2,
      param_001$2
    ];
    var match$4 = Matrix.matptmul(matrix, param$3);
    var startY = match$4[1];
    var startX = match$4[0];
    var param_000$3 = xCenterOfCircle + Math.cos(stop) * radx;
    var param_001$3 = yCenterOfCircle + Math.sin(stop) * rady;
    var param$4 = /* tuple */[
      param_000$3,
      param_001$3
    ];
    var match$5 = Matrix.matptmul(matrix, param$4);
    var stopY = match$5[1];
    var stopX = match$5[0];
    if (isPie) {
      drawLineInternal(env, /* tuple */[
            startX,
            startY
          ], /* tuple */[
            xCenterOfCircle,
            yCenterOfCircle
          ], strokeColor);
      drawLineInternal(env, /* tuple */[
            stopX,
            stopY
          ], /* tuple */[
            xCenterOfCircle,
            yCenterOfCircle
          ], strokeColor);
      drawEllipseInternal(env, Matrix.matptmul(matrix, /* tuple */[
                xCenterOfCircle,
                yCenterOfCircle
              ]), halfwidth, halfwidth, matrix, strokeColor);
    } else {
      drawLineInternal(env, /* tuple */[
            startX,
            startY
          ], /* tuple */[
            stopX,
            stopY
          ], strokeColor);
    }
    drawEllipseInternal(env, /* tuple */[
          startX,
          startY
        ], halfwidth, halfwidth, matrix, strokeColor);
    return drawEllipseInternal(env, /* tuple */[
                stopX,
                stopY
              ], halfwidth, halfwidth, matrix, strokeColor);
  }
}

function loadImage(env, filename) {
  var imageRef = [/* None */0];
  Curry._4(WGLWebgl.Gl[/* loadImage */30], filename, /* None */0, function (imageData) {
        if (imageData) {
          var img = imageData[0];
          var textureBuffer = Curry._1(WGLWebgl.Gl[/* createTexture */16], env[/* gl */2]);
          var height = Curry._1(WGLWebgl.Gl[/* getImageHeight */29], img);
          var width = Curry._1(WGLWebgl.Gl[/* getImageWidth */28], img);
          imageRef[0] = /* Some */[/* record */[
              /* textureBuffer */textureBuffer,
              /* img */img,
              /* height */height,
              /* width */width
            ]];
          Curry._3(WGLWebgl.Gl[/* bindTexture */18], env[/* gl */2], RGLConstants.texture_2d, textureBuffer);
          Curry._4(WGLWebgl.Gl[/* texImage2DWithImage */31], env[/* gl */2], RGLConstants.texture_2d, 0, img);
          Curry._4(WGLWebgl.Gl[/* texParameteri */19], env[/* gl */2], RGLConstants.texture_2d, RGLConstants.texture_mag_filter, RGLConstants.linear);
          return Curry._4(WGLWebgl.Gl[/* texParameteri */19], env[/* gl */2], RGLConstants.texture_2d, RGLConstants.texture_min_filter, RGLConstants.linear);
        } else {
          return Pervasives.failwith("Could not load image '" + (filename + "'."));
        }
      }, /* () */0);
  return imageRef;
}

function drawImageInternal(param, x, y, subx, suby, subw, subh, env) {
  var width = param[/* width */3];
  var height = param[/* height */2];
  var textureBuffer = param[/* textureBuffer */0];
  maybeFlushBatch(env, /* Some */[textureBuffer], 6);
  var match_000 = subx / width;
  var match_001 = suby / height;
  var match_002 = subw / width;
  var match_003 = subh / height;
  var fsubh = match_003;
  var fsubw = match_002;
  var fsuby = match_001;
  var fsubx = match_000;
  var match_000$1 = x + subw | 0;
  var match_001$1 = y + subh | 0;
  var match_001$2 = y + subh | 0;
  var match_000$2 = x + subw | 0;
  var set = WGLWebgl.Gl[/* Bigarray */36][/* set */4];
  var ii = env[/* batch */10][/* vertexPtr */2];
  var vertexArray = env[/* batch */10][/* vertexArray */0];
  Curry._3(set, vertexArray, ii + 0 | 0, match_000$1);
  Curry._3(set, vertexArray, ii + 1 | 0, match_001$1);
  Curry._3(set, vertexArray, ii + 2 | 0, 0.0);
  Curry._3(set, vertexArray, ii + 3 | 0, 0.0);
  Curry._3(set, vertexArray, ii + 4 | 0, 0.0);
  Curry._3(set, vertexArray, ii + 5 | 0, 0.0);
  Curry._3(set, vertexArray, ii + 6 | 0, fsubx + fsubw);
  Curry._3(set, vertexArray, ii + 7 | 0, fsuby + fsubh);
  Curry._3(set, vertexArray, ii + 8 | 0, x);
  Curry._3(set, vertexArray, ii + 9 | 0, match_001$2);
  Curry._3(set, vertexArray, ii + 10 | 0, 0.0);
  Curry._3(set, vertexArray, ii + 11 | 0, 0.0);
  Curry._3(set, vertexArray, ii + 12 | 0, 0.0);
  Curry._3(set, vertexArray, ii + 13 | 0, 0.0);
  Curry._3(set, vertexArray, ii + 14 | 0, fsubx);
  Curry._3(set, vertexArray, ii + 15 | 0, fsuby + fsubh);
  Curry._3(set, vertexArray, ii + 16 | 0, match_000$2);
  Curry._3(set, vertexArray, ii + 17 | 0, y);
  Curry._3(set, vertexArray, ii + 18 | 0, 0.0);
  Curry._3(set, vertexArray, ii + 19 | 0, 0.0);
  Curry._3(set, vertexArray, ii + 20 | 0, 0.0);
  Curry._3(set, vertexArray, ii + 21 | 0, 0.0);
  Curry._3(set, vertexArray, ii + 22 | 0, fsubx + fsubw);
  Curry._3(set, vertexArray, ii + 23 | 0, fsuby);
  Curry._3(set, vertexArray, ii + 24 | 0, x);
  Curry._3(set, vertexArray, ii + 25 | 0, y);
  Curry._3(set, vertexArray, ii + 26 | 0, 0.0);
  Curry._3(set, vertexArray, ii + 27 | 0, 0.0);
  Curry._3(set, vertexArray, ii + 28 | 0, 0.0);
  Curry._3(set, vertexArray, ii + 29 | 0, 0.0);
  Curry._3(set, vertexArray, ii + 30 | 0, fsubx);
  Curry._3(set, vertexArray, ii + 31 | 0, fsuby);
  var jj = env[/* batch */10][/* elementPtr */3];
  var elementArray = env[/* batch */10][/* elementArray */1];
  Curry._3(set, elementArray, jj, Caml_int32.div(ii, Common.vertexSize));
  Curry._3(set, elementArray, jj + 1 | 0, Caml_int32.div(ii, Common.vertexSize) + 1 | 0);
  Curry._3(set, elementArray, jj + 2 | 0, Caml_int32.div(ii, Common.vertexSize) + 2 | 0);
  Curry._3(set, elementArray, jj + 3 | 0, Caml_int32.div(ii, Common.vertexSize) + 1 | 0);
  Curry._3(set, elementArray, jj + 4 | 0, Caml_int32.div(ii, Common.vertexSize) + 2 | 0);
  Curry._3(set, elementArray, jj + 5 | 0, Caml_int32.div(ii, Common.vertexSize) + 3 | 0);
  env[/* batch */10][/* vertexPtr */2] = ii + (Common.vertexSize << 2) | 0;
  env[/* batch */10][/* elementPtr */3] = jj + 6 | 0;
  env[/* batch */10][/* currTex */4] = /* Some */[textureBuffer];
  return /* () */0;
}

function resetSize(env, width, height) {
  env[/* size */18][/* width */1] = width;
  env[/* size */18][/* height */0] = height;
  Curry._5(WGLWebgl.Gl[/* viewport */38], env[/* gl */2], 0, 0, width, height);
  Curry._5(WGLWebgl.Gl[/* clearColor */5], env[/* gl */2], 0, 0, 0, 1);
  Curry._7(WGLWebgl.Gl[/* Mat4 */44][/* ortho */6], env[/* camera */0][/* projectionMatrix */0], 0, width, height, 0, 0, 1);
  return Curry._3(WGLWebgl.Gl[/* uniformMatrix4fv */45], env[/* gl */2], env[/* pMatrixUniform */8], env[/* camera */0][/* projectionMatrix */0]);
}

exports.getProgram           = getProgram;
exports.createCanvas         = createCanvas;
exports.drawGeometry         = drawGeometry;
exports.flushGlobalBatch     = flushGlobalBatch;
exports.maybeFlushBatch      = maybeFlushBatch;
exports.toColorFloat         = toColorFloat;
exports.addRectToGlobalBatch = addRectToGlobalBatch;
exports.drawTriangleInternal = drawTriangleInternal;
exports.drawLineInternal     = drawLineInternal;
exports.drawArcInternal      = drawArcInternal;
exports.drawEllipseInternal  = drawEllipseInternal;
exports.drawArcStroke        = drawArcStroke;
exports.loadImage            = loadImage;
exports.drawImageInternal    = drawImageInternal;
exports.resetSize            = resetSize;
/* Utils Not a pure module */
