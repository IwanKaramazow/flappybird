// Generated by BUCKLESCRIPT VERSION 1.6.1, PLEASE EDIT WITH CARE
'use strict';

var $$Map       = require("bs-platform/lib/js/map");
var List        = require("bs-platform/lib/js/list");
var Curry       = require("bs-platform/lib/js/curry");
var Utils       = require("./utils");
var Common      = require("./common");
var $$String    = require("bs-platform/lib/js/string");
var Caml_obj    = require("bs-platform/lib/js/caml_obj");
var WGLWebgl    = require("reasongl-web/lib/js/src/wGLWebgl");
var Glhelpers   = require("./glhelpers");
var Pervasives  = require("bs-platform/lib/js/pervasives");
var Caml_format = require("bs-platform/lib/js/caml_format");

var compare = Caml_obj.caml_compare;

var IntMap = $$Map.Make(/* module */[/* compare */compare]);

function compare$1(param, param$1) {
  var a1 = param[0];
  var first = Caml_obj.caml_compare(a1, param$1[0]);
  if (first !== 0) {
    return first;
  } else {
    return Caml_obj.caml_compare(a1, param$1[1]);
  }
}

var IntPairMap = $$Map.Make(/* module */[/* compare */compare$1]);

function parse_num(_stream, _acc) {
  while(true) {
    var acc = _acc;
    var stream = _stream;
    var match = Curry._1(Common.Stream[/* peekch */1], stream);
    var exit = 0;
    var c;
    if (match) {
      var c$1 = match[0];
      if (c$1 >= 48) {
        if (c$1 >= 58) {
          exit = 1;
        } else {
          c = c$1;
          exit = 2;
        }
      } else if (c$1 !== 45) {
        exit = 1;
      } else {
        c = c$1;
        exit = 2;
      }
    } else {
      exit = 1;
    }
    switch (exit) {
      case 1 : 
          try {
            return /* tuple */[
                    stream,
                    Caml_format.caml_int_of_string(acc)
                  ];
          }
          catch (exn){
            return Pervasives.failwith("Could not parse number [" + (acc + "]."));
          }
          break;
      case 2 : 
          _acc = Common.append_char(acc, c);
          _stream = Curry._1(Common.Stream[/* popch */2], stream);
          continue ;
          
    }
  };
}

function parse_num$1(stream) {
  return parse_num(stream, "");
}

function parse_string(_stream, _acc) {
  while(true) {
    var acc = _acc;
    var stream = _stream;
    var match = Curry._1(Common.Stream[/* peekch */1], stream);
    if (match) {
      var c = match[0];
      if (c !== 34) {
        _acc = Common.append_char(acc, c);
        _stream = Curry._1(Common.Stream[/* popch */2], stream);
        continue ;
        
      } else {
        return /* tuple */[
                Curry._1(Common.Stream[/* popch */2], stream),
                acc
              ];
      }
    } else {
      return Pervasives.failwith("Unterminated string.");
    }
  };
}

function parse_string$1(stream) {
  return parse_string(stream, "");
}

function pop_line(_stream) {
  while(true) {
    var stream = _stream;
    var match = Curry._1(Common.Stream[/* peekch */1], stream);
    if (match) {
      if (match[0] !== 10) {
        _stream = Curry._1(Common.Stream[/* popch */2], stream);
        continue ;
        
      } else {
        return Curry._1(Common.Stream[/* popch */2], stream);
      }
    } else {
      return Pervasives.failwith("could not pop line");
    }
  };
}

function parse_char_fmt(_stream, _num, _map) {
  while(true) {
    var map = _map;
    var num = _num;
    var stream = _stream;
    if (num < 0) {
      return /* tuple */[
              stream,
              map
            ];
    } else {
      var stream$1 = Curry._2(Common.Stream[/* switch */5], stream, "char id=");
      var match = parse_num(stream$1, "");
      var stream$2 = Curry._2(Common.Stream[/* switch */5], match[0], " x=");
      var match$1 = parse_num(stream$2, "");
      var stream$3 = Curry._2(Common.Stream[/* switch */5], match$1[0], " y=");
      var match$2 = parse_num(stream$3, "");
      var stream$4 = Curry._2(Common.Stream[/* switch */5], match$2[0], " width=");
      var match$3 = parse_num(stream$4, "");
      var stream$5 = Curry._2(Common.Stream[/* switch */5], match$3[0], " height=");
      var match$4 = parse_num(stream$5, "");
      var stream$6 = Curry._2(Common.Stream[/* switch */5], match$4[0], " xoffset=");
      var match$5 = parse_num(stream$6, "");
      var stream$7 = Curry._2(Common.Stream[/* switch */5], match$5[0], " yoffset=");
      var match$6 = parse_num(stream$7, "");
      var stream$8 = Curry._2(Common.Stream[/* switch */5], match$6[0], " xadvance=");
      var match$7 = parse_num(stream$8, "");
      var stream$9 = pop_line(match$7[0]);
      var new_map = Curry._3(IntMap[/* add */3], match[1], /* record */[
            /* x */match$1[1],
            /* y */match$2[1],
            /* width */match$3[1],
            /* height */match$4[1],
            /* xoffset */match$5[1],
            /* yoffset */match$6[1],
            /* xadvance */match$7[1]
          ], map);
      _map = new_map;
      _num = num - 1 | 0;
      _stream = stream$9;
      continue ;
      
    }
  };
}

function parse_kern_fmt(_stream, _num, _map) {
  while(true) {
    var map = _map;
    var num = _num;
    var stream = _stream;
    if (num) {
      var stream$1 = Curry._2(Common.Stream[/* switch */5], stream, "kerning first=");
      var match = parse_num(stream$1, "");
      var stream$2 = Curry._2(Common.Stream[/* switch */5], match[0], " second=");
      var match$1 = parse_num(stream$2, "");
      var stream$3 = Curry._2(Common.Stream[/* switch */5], match$1[0], " amount=");
      var match$2 = parse_num(stream$3, "");
      var stream$4 = pop_line(match$2[0]);
      var new_map = Curry._3(IntPairMap[/* add */3], /* tuple */[
            match[1],
            match$1[1]
          ], match$2[1], map);
      _map = new_map;
      _num = num - 1 | 0;
      _stream = stream$4;
      continue ;
      
    } else {
      return /* tuple */[
              stream,
              map
            ];
    }
  };
}

function replaceFilename(path, filename) {
  var splitStr = Curry._2(Utils.PUtils[/* split */38], path, /* "/" */47);
  var revLst = List.rev(splitStr);
  var newRevLst = revLst ? /* :: */[
      filename,
      revLst[1]
    ] : /* [] */0;
  var newLst = List.rev(newRevLst);
  return $$String.concat("/", newLst);
}

function parseFontFormat(env, path) {
  var ret = [/* None */0];
  Curry._2(WGLWebgl.Gl[/* File */1][/* readFile */0], path, function (str) {
        var stream = Curry._1(Common.Stream[/* create */7], str + "\n");
        var stream$1 = pop_line(pop_line(stream));
        var stream$2 = Curry._2(Common.Stream[/* switch */5], stream$1, 'page id=0 file="');
        var match = parse_string(stream$2, "");
        var stream$3 = pop_line(match[0]);
        var stream$4 = Curry._2(Common.Stream[/* switch */5], stream$3, "chars count=");
        var match$1 = parse_num(stream$4, "");
        var stream$5 = pop_line(match$1[0]);
        var match$2 = parse_char_fmt(stream$5, match$1[1], IntMap[/* empty */0]);
        var stream$6 = Curry._2(Common.Stream[/* switch */5], match$2[0], "kernings count=");
        var match$3 = parse_num(stream$6, "");
        var stream$7 = pop_line(match$3[0]);
        var match$4 = parse_kern_fmt(stream$7, match$3[1], IntPairMap[/* empty */0]);
        var img_filename = replaceFilename(path, match[1]);
        ret[0] = /* Some */[/* record */[
            /* chars */match$2[1],
            /* kerning */match$4[1],
            /* image */Glhelpers.loadImage(env, img_filename)
          ]];
        return /* () */0;
      });
  return ret;
}

function getChar(fnt, ch) {
  try {
    return Curry._2(IntMap[/* find */21], ch, fnt[/* chars */0]);
  }
  catch (exn){
    return Pervasives.failwith("Could not find character " + (Pervasives.string_of_int(ch) + " in font."));
  }
}

function drawChar(env, fnt, image, ch, last, x, y) {
  var c = getChar(fnt, ch);
  var kernAmount;
  if (last) {
    try {
      kernAmount = Curry._2(IntPairMap[/* find */21], /* tuple */[
            last[0],
            ch
          ], fnt[/* kerning */1]);
    }
    catch (exn){
      kernAmount = 0;
    }
  } else {
    kernAmount = 0;
  }
  if (image) {
    Glhelpers.drawImageInternal(image[0], (x + c[/* xoffset */4] | 0) + kernAmount | 0, y + c[/* yoffset */5] | 0, c[/* x */0], c[/* y */1], c[/* width */2], c[/* height */3], env);
    return c[/* xadvance */6] + kernAmount | 0;
  } else {
    return c[/* xadvance */6] + kernAmount | 0;
  }
}

function drawString(env, fnt, str, x, y) {
  var match = fnt[0];
  if (match) {
    var fnt$1 = match[0];
    var match$1 = fnt$1[/* image */2][0];
    if (match$1) {
      var img = match$1[0];
      var offset = [x];
      var lastChar = [/* None */0];
      return $$String.iter(function (c) {
                  var advance = drawChar(env, fnt$1, /* Some */[img], c, lastChar[0], offset[0], y);
                  offset[0] = offset[0] + advance | 0;
                  lastChar[0] = /* Some */[c];
                  return /* () */0;
                }, str);
    } else {
      console.log("loading font.");
      return /* () */0;
    }
  } else {
    return /* () */0;
  }
}

function calcStringWidth(env, fnt, str) {
  var offset = [0];
  var lastChar = [/* None */0];
  $$String.iter(function (c) {
        offset[0] = offset[0] + drawChar(env, fnt, /* None */0, c, lastChar[0], offset[0], 0) | 0;
        lastChar[0] = /* Some */[c];
        return /* () */0;
      }, str);
  return offset[0];
}

var Font = /* module */[
  /* IntMap */IntMap,
  /* IntPairMap */IntPairMap,
  /* parse_num */parse_num$1,
  /* parse_string */parse_string$1,
  /* pop_line */pop_line,
  /* parse_char_fmt */parse_char_fmt,
  /* parse_kern_fmt */parse_kern_fmt,
  /* replaceFilename */replaceFilename,
  /* parseFontFormat */parseFontFormat,
  /* getChar */getChar,
  /* drawChar */drawChar,
  /* drawString */drawString,
  /* calcStringWidth */calcStringWidth
];

exports.Font = Font;
/* IntMap Not a pure module */
