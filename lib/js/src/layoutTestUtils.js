// Generated by BUCKLESCRIPT VERSION 1.6.1, PLEASE EDIT WITH CARE
'use strict';

var Sys         = require("bs-platform/lib/js/sys");
var List        = require("bs-platform/lib/js/list");
var $$Array     = require("bs-platform/lib/js/array");
var Curry       = require("bs-platform/lib/js/curry");
var $$String    = require("bs-platform/lib/js/string");
var Caml_obj    = require("bs-platform/lib/js/caml_obj");
var Caml_array  = require("bs-platform/lib/js/caml_array");
var Pervasives  = require("bs-platform/lib/js/pervasives");
var LayoutPrint = require("./layoutPrint");
var LayoutValue = require("./layoutValue");

function round(num) {
  return Math.floor(num + 0.5) | 0;
}

var exceptions = /* record */[/* contents : [] */0];

var failures = /* record */[/* contents : [] */0];

var testCount = /* record */[/* contents */0];

var assertionCount = /* record */[/* contents */0];

function isFilterArg(arg) {
  if (arg.length > 3) {
    return +($$String.sub(arg, 0, 3) === "---");
  } else {
    return /* false */0;
  }
}

function getSearchStr(arg) {
  return $$String.sub(arg, 3, arg.length - 3 | 0);
}

var match = +(Sys.argv.length > 1);

var testNameFilter = match !== 0 ? List.map(getSearchStr, List.find_all(isFilterArg)($$Array.to_list(Sys.argv))) : /* [] */0;

function hasAnArgMatching(tester) {
  if (Sys.argv.length > 1) {
    return +(List.length(List.find_all(tester)($$Array.to_list(Sys.argv))) > 0);
  } else {
    return /* false */0;
  }
}

var match$1 = hasAnArgMatching(function (arg) {
      return +($$String.compare(arg, "-quota") === 0);
    });

var runMode = match$1 !== 0 ? /* Bench */0 : /* Test */1;

var shouldBenchmarkAllAsOne = 1 - hasAnArgMatching(function (arg) {
      return +($$String.compare(arg, "-v") === 0);
    });

var currentTestName = /* record */[/* contents */""];

function doTest(desc, test) {
  currentTestName[/* contents */0] = desc;
  testCount[/* contents */0] = testCount[/* contents */0] + 1 | 0;
  try {
    return Curry._1(test, /* () */0);
  }
  catch (e){
    exceptions[/* contents */0] = /* :: */[
      /* tuple */[
        desc,
        e
      ],
      exceptions[/* contents */0]
    ];
    return /* () */0;
  }
}

function shouldRun(_$staropt$star, name) {
  while(true) {
    var $staropt$star = _$staropt$star;
    var filter = $staropt$star ? $staropt$star[0] : testNameFilter;
    if (filter) {
      var match = filter[1];
      var hd = filter[0];
      if (match) {
        if ($$String.compare(name, hd)) {
          _$staropt$star = /* Some */[/* :: */[
              match[0],
              match[1]
            ]];
          continue ;
          
        } else {
          return /* true */1;
        }
      } else {
        return +($$String.compare(name, hd) === 0);
      }
    } else {
      return /* true */1;
    }
  };
}

function it(_, desc, test) {
  if (shouldRun(/* None */0, desc)) {
    return doTest(desc, test);
  } else {
    return 0;
  }
}

function displayOutcomes() {
  var forEachException = function (param) {
    Pervasives.print_string("[Exception] " + param[0]);
    return Pervasives.print_newline(/* () */0);
  };
  var forEachFailure = function (param) {
    Pervasives.print_string("[TestFailure] " + (param[0] + (" - " + param[1])));
    return Pervasives.print_newline(/* () */0);
  };
  List.iter(forEachException, exceptions[/* contents */0]);
  List.iter(forEachFailure, failures[/* contents */0]);
  var exceptionsLength = List.length(exceptions[/* contents */0]);
  var failuresLength = List.length(failures[/* contents */0]);
  if (exceptionsLength === 0 && failuresLength === 0) {
    Pervasives.print_string("[SUCCESS] " + (Pervasives.string_of_int(testCount[/* contents */0]) + " tests passed"));
    Pervasives.print_newline(/* () */0);
  } else {
    Pervasives.print_newline(/* () */0);
    Pervasives.print_string("\xf0\x9f\x92\x80  \xf0\x9f\x92\x80  \xf0\x9f\x92\x80  \xf0\x9f\x92\x80");
    Pervasives.print_newline(/* () */0);
    Pervasives.print_string("[NON-SUCCESS] (" + (Pervasives.string_of_int(exceptionsLength) + ("/" + (Pervasives.string_of_int(testCount[/* contents */0]) + (") tests threw exceptions and (" + (Pervasives.string_of_int(failuresLength) + ("/" + (Pervasives.string_of_int(assertionCount[/* contents */0]) + ") assertions failed."))))))));
    Pervasives.print_newline(/* () */0);
    Pervasives.print_string("\xf0\x9f\x92\x80  \xf0\x9f\x92\x80  \xf0\x9f\x92\x80  \xf0\x9f\x92\x80");
    Pervasives.print_newline(/* () */0);
  }
  Pervasives.print_newline(/* () */0);
  if (List.length(exceptions[/* contents */0]) > 0) {
    var match = List.hd(List.rev(exceptions[/* contents */0]));
    throw match[1];
  }
  testCount[/* contents */0] = 0;
  assertionCount[/* contents */0] = 0;
  exceptions[/* contents */0] = /* [] */0;
  failures[/* contents */0] = /* [] */0;
  return /* () */0;
}

function assertEq(testNum, layoutAttr, a, b) {
  assertionCount[/* contents */0] = assertionCount[/* contents */0] + 1 | 0;
  if (a !== b) {
    failures[/* contents */0] = /* :: */[
      /* tuple */[
        currentTestName[/* contents */0],
        "Test " + (Pervasives.string_of_int(testNum) + (": " + (layoutAttr + (" not equal(expected=" + (Pervasives.string_of_float(a) + (", observed=" + (Pervasives.string_of_float(b) + ")")))))))
      ],
      failures[/* contents */0]
    ];
    return /* () */0;
  } else {
    return 0;
  }
}

function hasMismatchedLayout(_observedAndExpected) {
  while(true) {
    var observedAndExpected = _observedAndExpected;
    if (observedAndExpected) {
      var match = observedAndExpected[0];
      var observed = match[1];
      var expected = match[0];
      if (expected[/* top */1] !== observed[/* top */1]) {
        return /* true */1;
      } else if (expected[/* left */0] !== observed[/* left */0]) {
        return /* true */1;
      } else if (expected[/* width */4] !== observed[/* width */4]) {
        return /* true */1;
      } else if (expected[/* height */5] !== observed[/* height */5]) {
        return /* true */1;
      } else {
        _observedAndExpected = observedAndExpected[1];
        continue ;
        
      }
    } else {
      return /* false */0;
    }
  };
}

function best(cmp, extract, hd, tl) {
  if (tl) {
    var hdVal = Curry._1(extract, hd);
    var minFromTail = best(cmp, extract, tl[0], tl[1]);
    var match = Curry._2(cmp, minFromTail, hdVal);
    if (match !== 0) {
      return minFromTail;
    } else {
      return hdVal;
    }
  } else {
    return Curry._1(extract, hd);
  }
}

function renderBox(matrix, minLeft, minTop, layout, ch) {
  var leftIndex = LayoutValue.scalarToFloat(LayoutValue.$neg$dot(layout[/* left */0], minLeft)) | 0;
  var topIndex = LayoutValue.scalarToFloat(LayoutValue.$neg$dot(layout[/* top */1], minTop)) | 0;
  var rightIndex = round(LayoutValue.scalarToFloat(LayoutValue.$neg$dot(LayoutValue.$plus$dot(layout[/* left */0], layout[/* width */4]), minLeft)));
  var bottomIndex = round(LayoutValue.scalarToFloat(LayoutValue.$neg$dot(LayoutValue.$plus$dot(layout[/* top */1], layout[/* height */5]), minTop)));
  for(var y = topIndex; y <= bottomIndex; ++y){
    for(var x = leftIndex; x <= rightIndex; ++x){
      if (x === leftIndex || x === rightIndex || y === topIndex || y === bottomIndex) {
        Caml_array.caml_array_set(Caml_array.caml_array_get(matrix, x), y, ch);
      }
      
    }
  }
  return /* () */0;
}

function renderDiagram(containerLayout, childLayouts, containerChar, childChar) {
  var minLeft = best(Caml_obj.caml_lessthan, function (layout) {
        return layout[/* left */0];
      }, containerLayout, childLayouts);
  var minTop = best(Caml_obj.caml_lessthan, function (layout) {
        return layout[/* top */1];
      }, containerLayout, childLayouts);
  var maxRight = best(Caml_obj.caml_greaterthan, function (layout) {
        return LayoutValue.$plus$dot(layout[/* left */0], layout[/* width */4]);
      }, containerLayout, childLayouts);
  var maxBottom = best(Caml_obj.caml_greaterthan, function (layout) {
        return LayoutValue.$plus$dot(layout[/* top */1], layout[/* height */5]);
      }, containerLayout, childLayouts);
  var numCols = round(LayoutValue.scalarToFloat(LayoutValue.$neg$dot(maxRight, minLeft))) + 1 | 0;
  var numRows = round(LayoutValue.scalarToFloat(LayoutValue.$neg$dot(maxBottom, minTop))) + 1 | 0;
  var matrix = $$Array.make_matrix(numCols, numRows, /* "." */46);
  renderBox(matrix, minLeft, minTop, containerLayout, containerChar);
  List.iter(function (childLayout) {
        return renderBox(matrix, minLeft, minTop, childLayout, childChar);
      }, childLayouts);
  var ret = "";
  for(var y = 0 ,y_finish = numRows - 1 | 0; y <= y_finish; ++y){
    for(var x = 0 ,x_finish = numCols - 1 | 0; x <= x_finish; ++x){
      var ch = Caml_array.caml_array_get(Caml_array.caml_array_get(matrix, x), y);
      ret = ret + $$String.make(1, ch);
    }
    ret = ret + "\n";
  }
  return ret;
}

function mismatchText(param, childExpectedAndObserved) {
  var childStr = function (param) {
    return "  Child[expected(e)]:" + (LayoutPrint.layoutStr(param[0]) + ("\n  Child[observed(o)]:" + LayoutPrint.layoutStr(param[1])));
  };
  var containerExpected = "Container[expected(E)]:" + (LayoutPrint.layoutStr(param[0]) + "\n");
  var containerObserved = "Container[observed(O)]:" + (LayoutPrint.layoutStr(param[1]) + "\n");
  return containerExpected + (containerObserved + $$String.concat("\n", List.map(childStr, childExpectedAndObserved)));
}

function assertLayouts(testNum, param, childExpectedAndObserved) {
  var observedContainerLayout = param[1];
  var expectedContainerLayout = param[0];
  assertionCount[/* contents */0] = assertionCount[/* contents */0] + 1 | 0;
  if (hasMismatchedLayout(/* :: */[
          /* tuple */[
            expectedContainerLayout,
            observedContainerLayout
          ],
          childExpectedAndObserved
        ])) {
    var text = mismatchText(/* tuple */[
          expectedContainerLayout,
          observedContainerLayout
        ], childExpectedAndObserved);
    var expectedDiagram = renderDiagram(expectedContainerLayout, List.map(function (prim) {
              return prim[0];
            }, childExpectedAndObserved), /* "E" */69, /* "e" */101);
    var observedDiagram = renderDiagram(observedContainerLayout, List.map(function (prim) {
              return prim[1];
            }, childExpectedAndObserved), /* "O" */79, /* "o" */111);
    var title = "Test " + (Pervasives.string_of_int(testNum) + ":\n");
    var expected = "\nEXPECTED\n========\n" + expectedDiagram;
    var observed = "\nOBSERVED\n========\n" + observedDiagram;
    failures[/* contents */0] = /* :: */[
      /* tuple */[
        currentTestName[/* contents */0],
        title + (text + (expected + observed))
      ],
      failures[/* contents */0]
    ];
    return /* () */0;
  } else {
    return 0;
  }
}

exports.round                   = round;
exports.exceptions              = exceptions;
exports.failures                = failures;
exports.testCount               = testCount;
exports.assertionCount          = assertionCount;
exports.isFilterArg             = isFilterArg;
exports.getSearchStr            = getSearchStr;
exports.testNameFilter          = testNameFilter;
exports.hasAnArgMatching        = hasAnArgMatching;
exports.runMode                 = runMode;
exports.shouldBenchmarkAllAsOne = shouldBenchmarkAllAsOne;
exports.currentTestName         = currentTestName;
exports.doTest                  = doTest;
exports.shouldRun               = shouldRun;
exports.it                      = it;
exports.displayOutcomes         = displayOutcomes;
exports.assertEq                = assertEq;
exports.hasMismatchedLayout     = hasMismatchedLayout;
exports.best                    = best;
exports.renderBox               = renderBox;
exports.renderDiagram           = renderDiagram;
exports.mismatchText            = mismatchText;
exports.assertLayouts           = assertLayouts;
/* testNameFilter Not a pure module */
